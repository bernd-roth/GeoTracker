package at.co.netconsulting.geotracker.kml

import android.content.ContentValues
import android.content.Context
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.util.Log
import android.widget.Toast
import at.co.netconsulting.geotracker.domain.FitnessTrackerDatabase
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter

suspend fun export(eventId: Int, contextActivity: Context) {
    val database = FitnessTrackerDatabase.getInstance(contextActivity)
    try {
        withContext(Dispatchers.IO) {
            val event = database.eventDao().getEventById(eventId)
            val locations = database.locationDao().getLocationsByEventId(eventId)
            val metrics = database.metricDao().getMetricsByEventId(eventId)
            val weather = database.weatherDao().getWeatherForEvent(eventId)

            if (locations.isEmpty()) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(contextActivity, "No location data to export", Toast.LENGTH_SHORT).show()
                }
                return@withContext
            }

            // Map sport type to activity type for descriptions
            val activityType = when (event?.artOfSport?.lowercase()) {
                "running", "jogging", "marathon" -> "Running"
                "cycling", "bicycle", "bike", "biking" -> "Cycling"
                "hiking", "walking", "trekking" -> "Hiking"
                "duathlon", "triathlon", "ultratriathlon", "multisport race" -> "Multisport"
                else -> event?.artOfSport ?: "Activity"
            }

            // Create KML content
            val kmlBuilder = StringBuilder()
            if (event != null) {
                kmlBuilder.append("""<?xml version="1.0" encoding="UTF-8"?>
                        |<kml xmlns="http://www.opengis.net/kml/2.2">
                        |  <Document>
                        |    <name>${event.eventName}</name>
                        |    <description>
                        |      <![CDATA[
                        |        <h3>${event.eventName}</h3>
                        |        <p><strong>Date:</strong> ${event.eventDate}</p>
                        |        <p><strong>Sport:</strong> ${event.artOfSport}</p>""".trimMargin())

                // Add weather info if available
                weather.firstOrNull()?.let { w ->
                    kmlBuilder.append("""
                        |        <p><strong>Weather:</strong> ${w.temperature}Â°C, Wind: ${w.windSpeed} km/h ${w.windDirection}, Humidity: ${w.relativeHumidity}%</p>""".trimMargin())
                }

                kmlBuilder.append("""
                        |        <p>Generated by GeoTracker</p>
                        |      ]]>
                        |    </description>
                        |    <Style id="trackStyle">
                        |      <LineStyle>
                        |        <color>ff0000ff</color>
                        |        <width>3</width>
                        |      </LineStyle>
                        |    </Style>
                        |    <Style id="startPointStyle">
                        |      <IconStyle>
                        |        <color>ff00ff00</color>
                        |        <scale>1.0</scale>
                        |        <Icon>
                        |          <href>http://maps.google.com/mapfiles/kml/pushpin/grn-pushpin.png</href>
                        |        </Icon>
                        |      </IconStyle>
                        |    </Style>
                        |    <Style id="endPointStyle">
                        |      <IconStyle>
                        |        <color>ff0000ff</color>
                        |        <scale>1.0</scale>
                        |        <Icon>
                        |          <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>
                        |        </Icon>
                        |      </IconStyle>
                        |    </Style>
                        |    <Placemark>
                        |      <name>${event.eventName} - Start</name>
                        |      <description>
                        |        <![CDATA[
                        |          <p><strong>Start Point</strong></p>
                        |          <p>Time: ${formatTimestamp(metrics.firstOrNull()?.timeInMilliseconds ?: 0)}</p>${if (event.startAddress != null || event.startCity != null) "\n          <p>Location: ${event.startAddress ?: "${event.startCity ?: ""}, ${event.startCountry ?: ""}"}</p>" else ""}
                        |        ]]>
                        |      </description>
                        |      <styleUrl>#startPointStyle</styleUrl>
                        |      <Point>
                        |        <coordinates>${locations.first().longitude},${locations.first().latitude},${locations.first().altitude}</coordinates>
                        |      </Point>
                        |    </Placemark>
                        |    <Placemark>
                        |      <name>${event.eventName} - End</name>
                        |      <description>
                        |        <![CDATA[
                        |          <p><strong>End Point</strong></p>
                        |          <p>Time: ${formatTimestamp(metrics.lastOrNull()?.timeInMilliseconds ?: 0)}</p>${if (event.endAddress != null || event.endCity != null) "\n          <p>Location: ${event.endAddress ?: "${event.endCity ?: ""}, ${event.endCountry ?: ""}"}</p>" else ""}
                        |        ]]>
                        |      </description>
                        |      <styleUrl>#endPointStyle</styleUrl>
                        |      <Point>
                        |        <coordinates>${locations.last().longitude},${locations.last().latitude},${locations.last().altitude}</coordinates>
                        |      </Point>
                        |    </Placemark>
                        |    <Placemark>
                        |      <name>${event.eventName} - Route</name>
                        |      <description>${activityType} route tracked by GeoTracker</description>
                        |      <styleUrl>#trackStyle</styleUrl>
                        |      <LineString>
                        |        <extrude>1</extrude>
                        |        <tessellate>1</tessellate>
                        |        <altitudeMode>absolute</altitudeMode>
                        |        <coordinates>
                        """.trimMargin())

                // Add all coordinates
                locations.forEach { location ->
                    kmlBuilder.append("          ${location.longitude},${location.latitude},${location.altitude}\n")
                }

                kmlBuilder.append("""        </coordinates>
                        |      </LineString>
                        |    </Placemark>""".trimMargin())

                // Add waypoints/laps if available
                locations.forEachIndexed { index, location ->
                    val metric = metrics.getOrNull(index)
                    metric?.let { m ->
                        // Add a placemark for every 1km (1000m) milestone
                        if (m.distance > 0 && (m.distance % 1000) < 10 && m.distance >= 1000) {
                            val kmMark = (m.distance / 1000).toInt()
                            kmlBuilder.append("""
                        |    <Placemark>
                        |      <name>${kmMark}km Mark</name>
                        |      <description>
                        |        <![CDATA[
                        |          <p><strong>${kmMark} km milestone</strong></p>
                        |          <p>Distance: ${String.format("%.2f", m.distance / 1000.0)} km</p>
                        |          <p>Time: ${formatTimestamp(m.timeInMilliseconds)}</p>""".trimMargin())

                            if (m.heartRate > 0) {
                                kmlBuilder.append("\n          <p>Heart Rate: ${m.heartRate} bpm</p>")
                            }
                            if (m.speed > 0) {
                                kmlBuilder.append("\n          <p>Speed: ${String.format("%.1f", m.speed * 3.6)} km/h</p>")
                            }

                            kmlBuilder.append("""
                        |        ]]>
                        |      </description>
                        |      <Point>
                        |        <coordinates>${location.longitude},${location.latitude},${location.altitude}</coordinates>
                        |      </Point>
                        |    </Placemark>""".trimMargin())
                        }
                    }
                }

                kmlBuilder.append("""
                        |  </Document>
                        |</kml>""".trimMargin())
            }

            val filename = "${event?.eventName}_${event?.eventDate}.kml"
                .replace(" ", "_")
                .replace(":", "-")
                .replace("[^a-zA-Z0-9._-]".toRegex(), "_")

            // Save file using modern storage approach
            val success = saveKmlFile(contextActivity, filename, kmlBuilder.toString())

            withContext(Dispatchers.Main) {
                if (success) {
                    Toast.makeText(
                        contextActivity,
                        "KML file exported: $filename",
                        Toast.LENGTH_LONG
                    ).show()
                } else {
                    Toast.makeText(
                        contextActivity,
                        "Failed to export KML file. Check storage permissions.",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }
    } catch (e: Exception) {
        Log.e("KMLExport", "Error exporting KML", e)
        withContext(Dispatchers.Main) {
            Toast.makeText(
                contextActivity,
                "Error exporting KML: ${e.message}",
                Toast.LENGTH_LONG
            ).show()
        }
    }
}

/**
 * Save KML file using modern storage approaches
 * Works with both older Android versions and Android 10+ scoped storage
 */
fun saveKmlFile(context: Context, filename: String, content: String): Boolean {
    return try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Android 10+ (API 29+) - Use scoped storage
            saveKmlFileScoped(context, filename, content)
        } else {
            // Android 9 and below - Use traditional file approach
            saveKmlFileLegacy(context, filename, content)
        }
    } catch (e: Exception) {
        Log.e("KMLExport", "Error saving KML file", e)
        false
    }
}

/**
 * Save KML file using scoped storage (Android 10+)
 * No permissions required!
 */
private fun saveKmlFileScoped(context: Context, filename: String, content: String): Boolean {
    return try {
        val resolver = context.contentResolver
        val contentValues = ContentValues().apply {
            put(MediaStore.MediaColumns.DISPLAY_NAME, filename)
            put(MediaStore.MediaColumns.MIME_TYPE, "application/vnd.google-earth.kml+xml")
            put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS + "/GeoTracker/KML")
        }

        val uri = resolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, contentValues)
        uri?.let { fileUri ->
            resolver.openOutputStream(fileUri)?.use { outputStream ->
                outputStream.write(content.toByteArray())
                outputStream.flush()
            }
            true
        } ?: false
    } catch (e: Exception) {
        Log.e("KMLExport", "Error with scoped storage", e)
        false
    }
}

/**
 * Save KML file using legacy approach (Android 9 and below)
 * Requires WRITE_EXTERNAL_STORAGE permission
 */
private fun saveKmlFileLegacy(context: Context, filename: String, content: String): Boolean {
    return try {
        // Try app-specific directory first (no permissions needed)
        val appDir = File(context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS), "GeoTracker/KML")
        if (!appDir.exists()) {
            appDir.mkdirs()
        }

        val file = File(appDir, filename)
        FileOutputStream(file).use { output ->
            output.write(content.toByteArray())
        }

        Log.d("KMLExport", "KML saved to app directory: ${file.absolutePath}")
        true
    } catch (e: Exception) {
        Log.e("KMLExport", "Error with legacy storage", e)
        // Fallback: try public Downloads (requires permission)
        try {
            val publicDir = File(
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
                "GeoTracker/KML"
            )
            if (!publicDir.exists()) {
                publicDir.mkdirs()
            }

            val file = File(publicDir, filename)
            FileOutputStream(file).use { output ->
                output.write(content.toByteArray())
            }

            Log.d("KMLExport", "KML saved to public directory: ${file.absolutePath}")
            true
        } catch (e2: Exception) {
            Log.e("KMLExport", "Both storage methods failed", e2)
            false
        }
    }
}

private fun formatTimestamp(timestampMs: Long): String {
    return if (timestampMs > 0) {
        Instant.ofEpochMilli(timestampMs)
            .atZone(ZoneId.systemDefault())
            .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
    } else {
        "N/A"
    }
}