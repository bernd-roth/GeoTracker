<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Tracker - Speed & Elevation Display</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }

        #map {
            height: 67vh;
            width: 100%;
        }

        /* Keep only the essential controls */
        #essentialControls {
            position: absolute;
            top: 12px;
            left: 50px;
            z-index: 1000;
            background-color: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
        }

        #essentialControls button {
            padding: 4px 8px;
            background-color: white;
            border: 2px solid rgba(0,0,0,0.2);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            color: #666;
        }

        #essentialControls button:hover {
            background-color: #f4f4f4;
        }

        /* Modified speedDisplay to have a fixed height and scrolling */
        #speedDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px 0;
            border-radius: 5px;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
            width: 280px;
            max-height: 600px; /* Set a max height for 2 sessions */
            overflow-y: auto; /* Enable scrolling */
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 10px;
        }

        .stat-box {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .speed-value, .heart-rate-value {
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
        }

        .elevation-value {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .speed-unit, .elevation-unit, .heart-rate-unit {
            font-size: 14px;
            color: #666;
        }

        .speed-label, .elevation-label, .heart-rate-label {
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }

        .charts-container {
            height: 33vh;
            width: 100%;
            display: flex;
            padding: 0;
        }

        #altitudeChartContainer,
        #speedChartContainer {
            height: 100%;
            width: 50%;
            padding: 0;
        }

        #altitudeChart,
        #speedChart {
            height: 100%;
            width: 100%;
        }

        .session-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: white;
            padding: 5px 10px;
            border-radius: 3px;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #333;
            z-index: 1000;
            transform: none;
            display: inline-block;
        }

        /* Session container styles */
        .session-container {
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .session-container:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .session-label {
            font-size: 12px;
            font-weight: bold;
            padding: 0 10px;
            margin-bottom: 5px;
            color: #333;
        }

        /* Scrollbar styling */
        #speedDisplay::-webkit-scrollbar {
            width: 6px;
        }

        #speedDisplay::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        #speedDisplay::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        #speedDisplay::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Debug Popup Styles */
        #debugToggle {
            background-color: white;
            padding: 5px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #debugToggle:hover {
            background-color: #0b7dda;
        }

        #debugPopup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 900px;
            height: 80%;
            max-height: 600px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            overflow: hidden;
            flex-direction: column;
        }

        #debugPopupHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #f3f3f3;
            border-bottom: 1px solid #ddd;
        }

        #debugPopupTitle {
            font-weight: bold;
            margin: 0;
        }

        #debugPopupClose {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }

        #debugContent {
            flex: 1;
            padding: 15px;
            overflow: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .debug-controls {
            display: flex;
            padding: 10px 15px;
            background-color: #f3f3f3;
            border-top: 1px solid #ddd;
            gap: 10px;
        }

        .debug-controls button {
            padding: 6px 12px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .debug-controls button:hover {
            background-color: #0b7dda;
        }

        #debugFilter {
            flex: 1;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        #debugContent .message {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            word-wrap: break-word;
        }

        #debugContent .message-timestamp {
            color: #999;
            font-size: 11px;
            margin-right: 8px;
        }

        #debugContent .update-message {
            color: #4CAF50;
        }

        #debugContent .batch-message {
            color: #2196F3;
        }

        .message-highlight {
            background-color: #FFFF88;
        }

        #debugOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1999;
        }

        .control-panel {
            position: absolute;
            top: 80px;
            left: 10px;
            z-index: 1000;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
            width: 280px;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: #f3f3f3;
            border-bottom: 1px solid #ddd;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #333;
        }

        .panel-toggle {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            color: #666;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .sessions-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .session-item {
            padding: 8px 10px;
            border-radius: 4px;
            margin-bottom: 5px;
            background-color: #f5f5f5;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .session-item:hover {
            background-color: #e9e9e9;
        }

        .session-item.active {
            background-color: #e3f2fd;
            border-left: 3px solid #2196F3;
        }

        .session-item-info {
            flex: 1;
        }

        .session-item-name {
            font-weight: bold;
            font-size: 12px;
            color: #333;
        }

        .session-item-time {
            font-size: 10px;
            color: #666;
        }

        .session-actions {
            display: flex;
            gap: 5px;
        }

        .session-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .session-action-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .session-action-btn.delete {
            color: #F44336;
        }

        .session-action-btn.zoom-to-session {
            color: #2196F3;
        }

        .session-action-btn.zoom-to-session:hover {
            background-color: rgba(33, 150, 243, 0.1);
        }

        .session-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-list-header h4 {
            margin: 0;
            font-size: 13px;
            color: #666;
        }

        .no-sessions {
            font-size: 12px;
            color: #999;
            text-align: center;
            padding: 20px 0;
        }

        .confirm-delete {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            z-index: 2001;
            text-align: center;
            width: 300px;
        }

        .confirm-delete h3 {
            margin-top: 0;
        }

        .confirm-delete p {
            margin-bottom: 20px;
        }

        .confirm-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .confirm-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .confirm-btn.cancel {
            background-color: #f5f5f5;
            color: #333;
        }

        .confirm-btn.delete {
            background-color: #F44336;
            color: white;
        }

        /* Enhanced popup styling with barometer data support */
        #chartInfoPopup {
            position: fixed !important;
            background: white !important;
            border: 2px solid #333 !important;
            border-radius: 8px !important;
            padding: 12px !important;
            font-family: Arial, sans-serif !important;
            font-size: 12px !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
            z-index: 9999 !important;
            display: none;
            pointer-events: none !important;
            max-width: 380px !important;
            line-height: 1.4 !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Specific class for when popup should be visible */
        #chartInfoPopup.popup-visible {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Weather & Barometer info popup styling */
        #chartInfoPopup .weather-section {
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
            border-left: 3px solid #FF5722;
        }

        #chartInfoPopup .weather-header {
            font-weight: bold;
            color: #FF5722;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }

        #chartInfoPopup .weather-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 10px;
        }

        #chartInfoPopup .weather-item {
            text-align: center;
        }

        #chartInfoPopup .weather-label {
            font-weight: bold;
            margin-bottom: 2px;
        }

        #chartInfoPopup .weather-value {
            color: #333;
            font-size: 11px;
        }

        #chartInfoPopup .weather-footer {
            margin-top: 6px;
            font-size: 9px;
            color: #666;
            font-style: italic;
            text-align: center;
        }

        /* Weather-specific color classes */
        .weather-value.temperature {
            color: #FF5722;
            font-weight: bold;
        }

        .weather-value.humidity {
            color: #2196F3;
            font-weight: bold;
        }

        .weather-value.wind {
            color: #795548;
            font-weight: bold;
        }

        .weather-value.pressure {
            color: #9C27B0;
            font-weight: bold;
        }

        .weather-value.barometer {
            color: #607D8B;
            font-weight: bold;
        }

        @keyframes fadeInWeather {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .weather-section {
            animation: fadeInWeather 0.3s ease-in;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            #chartInfoPopup {
                max-width: 320px !important;
                font-size: 11px !important;
            }

            #chartInfoPopup .weather-grid {
                font-size: 9px;
            }

            #chartInfoPopup .weather-value {
                font-size: 10px;
            }

            #speedDisplay {
                width: 240px;
                max-height: 400px;
            }

            .control-panel {
                width: 240px;
            }
        }
    </style>
</head>
<body>
<!-- Keep only essential controls: Hide Stats and Debug -->
<div id="essentialControls">
    <button id="toggleStatsBtn" onclick="toggleStatBoxes()">Hide Stats</button>
    <button id="debugToggle" onclick="toggleDebugPopup()">Show Debug Data</button>
</div>

<div id="speedDisplay">
    <div class="stats-grid">
        <div class="stat-box">
            <div class="speed-label">Current Speed</div>
            <div class="speed-value" id="currentSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Maximum Speed</div>
            <div class="speed-value" id="maxSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Average Speed</div>
            <div class="speed-value" id="avgSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Moving Average</div>
            <div class="speed-value" id="movingAvg">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="elevation-label">Elevation Gain</div>
            <div class="elevation-value" id="elevationGain">0.0</div>
            <div class="elevation-unit">m</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Distance</div>
            <div class="elevation-value" id="totalDistance">0.0</div>
            <div class="elevation-unit">km</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Heart Rate</div>
            <div class="speed-value" id="heartRate">0</div>
            <div class="speed-unit">bpm</div>
        </div>
    </div>
</div>

<!-- KEEP the Session Manager Panel -->
<div id="sessionManagerPanel" class="control-panel">
    <div class="panel-header">
        <h3>Session Manager</h3>
        <button id="toggleSessionPanel" class="panel-toggle" onclick="toggleSessionPanel()">-</button>
    </div>
    <div class="panel-content">
        <div class="session-list-header">
            <h4>Available Sessions</h4>
            <div class="session-controls">
                <button id="refreshSessionsBtn" onclick="requestSessionList()" title="Refresh Sessions">‚Üª</button>
            </div>
        </div>
        <div id="sessionsList" class="sessions-container">
            <p class="no-sessions">No active sessions found.</p>
        </div>
    </div>
</div>

<div id="map"></div>
<div class="charts-container">
    <div id="altitudeChartContainer">
        <canvas id="altitudeChart"></canvas>
    </div>
    <div id="speedChartContainer">
        <canvas id="speedChart"></canvas>
    </div>
</div>
<div id="sessionInfo" class="session-info"></div>

<!-- Debug Popup -->
<div id="debugOverlay" onclick="toggleDebugPopup()"></div>
<div id="debugPopup">
    <div id="debugPopupHeader">
        <h3 id="debugPopupTitle">Data Trace Debug</h3>
        <button id="debugPopupClose" onclick="toggleDebugPopup()">√ó</button>
    </div>
    <div id="debugContent"></div>
    <div class="debug-controls">
        <input type="text" id="debugFilter" placeholder="Filter messages..." oninput="filterDebugMessages()">
        <button onclick="clearDebugLog()">Clear Log</button>
        <button onclick="exportDebugLog()">Export Log</button>
        <button onclick="pauseDebugLog()" id="pauseButton">Pause</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
<script>
    // Global variables
    let map;
    let websocket;
    let polylines = {};
    let startMarkers = {};
    let endMarkers = {};
    let altitudeChart;
    let speedChart;
    let speedHistory = {};
    let elevationHistory = {};
    let userColors = {};
    let trackPoints = {};
    let isProcessingBatch = false;
    let statsVisible = true; // Track the visibility state of stat boxes
    let sessionPersonNames = {};
    let availableSessions = [];
    let sessionPanelVisible = true;

    // Interactive chart variables
    let hoverMarker = null;
    let infoPopup = null;
    let currentHoverPoint = null;

    // Debug variables
    let debugMessages = [];
    let debugPaused = false;
    let maxDebugMessages = 1000; // Limit to prevent browser slowdown

    // Weather statistics tracking
    let weatherStats = {
        totalUpdates: 0,
        lastTemperature: null,
        lastUpdate: null,
        temperatureRange: { min: null, max: null }
    };

    function getRandomInRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function initMap() {
        try {
            console.log("Initializing map...");
            const initialLocation = [48.1818798, 16.3607528]; // Use Vienna as default location
            map = L.map('map', {
                worldCopyJump: false,
                maxBounds: [[-90, -180], [90, 180]],
                minZoom: 1
            }).setView(initialLocation, 3);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                noWrap: true
            }).addTo(map);

            console.log("Map initialized successfully");

            initCharts();
            connectToWebSocket();
        } catch (error) {
            console.error("Error initializing map:", error);
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '<div style="text-align: center; padding: 20px; color: red;">Error loading map. Please check console for details.</div>';
            }
        }
    }

    function initCharts() {
        const baseChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            elements: {
                line: {
                    tension: 0
                },
                point: {
                    radius: 0,
                    hoverRadius: 6
                }
            },
            plugins: {
                legend: {
                    onClick: handleLegendClick
                },
                tooltip: {
                    enabled: false
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'Distance (km)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Altitude (m)'
                    },
                    min: 0
                }
            },
            onHover: (event, activeElements) => {
                console.log('üéØ CHART HOVER EVENT FIRED:', {
                    elementCount: activeElements.length,
                    hasEvent: !!event,
                    eventType: event?.type,
                    chartCanvas: event?.native?.target?.id || 'unknown'
                });

                addDebugMessage(`Chart hover event triggered with ${activeElements.length} active elements`, 'interaction');

                if (event.native && event.native.target) {
                    event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                }

                handleChartHover(event, activeElements, 'altitude');
            },
            onClick: (event, activeElements) => {
                console.log('üéØ CHART CLICK EVENT FIRED:', activeElements.length, 'elements');
                addDebugMessage(`Chart click event triggered with ${activeElements.length} active elements`, 'interaction');
                handleChartClick(event, activeElements, 'altitude');
            }
        };

        try {
            altitudeChart = new Chart(
                document.getElementById('altitudeChart').getContext('2d'),
                {
                    type: 'line',
                    data: { datasets: [] },
                    options: baseChartOptions
                }
            );
            console.log('‚úÖ Altitude chart created successfully');
        } catch (error) {
            console.error('‚ùå Error creating altitude chart:', error);
            addDebugMessage(`Error creating altitude chart: ${error.message}`, 'error');
        }

        const speedChartOptions = {
            ...baseChartOptions,
            scales: {
                ...baseChartOptions.scales,
                y: {
                    ...baseChartOptions.scales.y,
                    title: {
                        display: true,
                        text: 'Speed (km/h)'
                    }
                }
            },
            onHover: (event, activeElements) => {
                console.log('üéØ SPEED CHART HOVER EVENT FIRED:', {
                    elementCount: activeElements.length,
                    hasEvent: !!event,
                    chartCanvas: event?.native?.target?.id || 'unknown'
                });

                addDebugMessage(`Speed chart hover event triggered with ${activeElements.length} active elements`, 'interaction');

                if (event.native && event.native.target) {
                    event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                }

                handleChartHover(event, activeElements, 'speed');
            },
            onClick: (event, activeElements) => {
                console.log('üéØ SPEED CHART CLICK EVENT FIRED:', activeElements.length, 'elements');
                addDebugMessage(`Speed chart click event triggered with ${activeElements.length} active elements`, 'interaction');
                handleChartClick(event, activeElements, 'speed');
            }
        };

        try {
            speedChart = new Chart(
                document.getElementById('speedChart').getContext('2d'),
                {
                    type: 'line',
                    data: { datasets: [] },
                    options: speedChartOptions
                }
            );
            console.log('‚úÖ Speed chart created successfully');
        } catch (error) {
            console.error('‚ùå Error creating speed chart:', error);
            addDebugMessage(`Error creating speed chart: ${error.message}`, 'error');
        }

        createInfoPopup();

        setTimeout(() => {
            testChartSetup();
        }, 100);
    }

    function createInfoPopup() {
        const existingPopup = document.getElementById('chartInfoPopup');
        if (existingPopup) {
            existingPopup.remove();
            console.log('üóëÔ∏è Removed existing popup');
        }

        try {
            infoPopup = document.createElement('div');
            infoPopup.id = 'chartInfoPopup';

            infoPopup.style.cssText = `
                position: fixed !important;
                background: white !important;
                border: 2px solid #333 !important;
                border-radius: 8px !important;
                padding: 12px !important;
                font-family: Arial, sans-serif !important;
                font-size: 12px !important;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
                z-index: 9999 !important;
                display: none !important;
                pointer-events: none !important;
                max-width: 320px !important;
                line-height: 1.4 !important;
                color: #333 !important;
            `;

            document.body.appendChild(infoPopup);
            console.log('‚úÖ Info popup created and added to DOM');
            addDebugMessage('Info popup element created and added to DOM', 'system');

            const verifyPopup = document.getElementById('chartInfoPopup');
            if (!verifyPopup) {
                throw new Error('Popup not found in DOM after creation');
            }

        } catch (error) {
            console.error('‚ùå Error creating info popup:', error);
            addDebugMessage(`Error creating info popup: ${error.message}`, 'error');
        }
    }

    function handleChartHover(event, activeElements, chartType) {
        console.log(`üîç handleChartHover called for ${chartType} chart:`, {
            activeElementsCount: activeElements ? activeElements.length : 0,
            hasEvent: !!event,
            infoPopupExists: !!infoPopup
        });

        if (!activeElements || activeElements.length === 0) {
            console.log('‚ùå No active elements, hiding hover effects');
            hideHoverMarker();
            hideInfoPopup();
            return;
        }

        try {
            const element = activeElements[0];
            const datasetIndex = element.datasetIndex;
            const dataIndex = element.index;

            console.log(`üìä Processing hover:`, {
                datasetIndex,
                dataIndex,
                chartType
            });

            const chart = chartType === 'altitude' ? altitudeChart : speedChart;
            const dataset = chart.data.datasets[datasetIndex];

            if (!dataset) {
                console.log('‚ùå No dataset found at index:', datasetIndex);
                addDebugMessage(`No dataset found at index ${datasetIndex}`, 'warning');
                return;
            }

            console.log(`üìà Found dataset:`, {
                label: dataset.label,
                dataLength: dataset.data ? dataset.data.length : 0
            });

            let sessionId = dataset.label;
            let sessionTrackPoints = trackPoints[sessionId];

            if (!sessionTrackPoints) {
                if (sessionId.includes('_') && sessionId !== 'GPX Track') {
                    const parts = sessionId.split('_');
                    if (parts.length > 1) {
                        const extractedId = parts.slice(1).join('_');
                        sessionTrackPoints = trackPoints[extractedId];
                        if (sessionTrackPoints) {
                            sessionId = extractedId;
                            console.log('‚úÖ Found using extracted ID:', sessionId);
                        }
                    }
                }
            }

            if (!sessionTrackPoints) {
                console.log('‚ùå No track points found. Available sessions:', Object.keys(trackPoints));
                addDebugMessage(`No track points found for session: ${sessionId}`, 'warning');
                return;
            }

            if (!sessionTrackPoints[dataIndex]) {
                console.log('‚ùå No track point at index:', dataIndex, 'of', sessionTrackPoints.length);
                addDebugMessage(`No track point at index ${dataIndex}`, 'warning');
                return;
            }

            const point = sessionTrackPoints[dataIndex];

            console.log(`üìç Found point:`, {
                lat: point.lat,
                lng: point.lng,
                distance: point.distance,
                altitude: point.altitude
            });

            showHoverMarker(point.lat, point.lng, sessionId);
            showInfoPopup(event, point, sessionId, chartType);

            console.log('‚úÖ Hover processing completed successfully');
            addDebugMessage(`Hover successful - Session: ${sessionId}, Point: ${dataIndex}`, 'interaction');

        } catch (error) {
            console.error('‚ùå Error in handleChartHover:', error);
            addDebugMessage(`Hover error: ${error.message}`, 'error');
        }
    }

    function handleChartClick(event, activeElements, chartType) {
        if (!activeElements || activeElements.length === 0) return;

        const element = activeElements[0];
        const datasetIndex = element.datasetIndex;
        const dataIndex = element.index;

        const chart = chartType === 'altitude' ? altitudeChart : speedChart;
        const dataset = chart.data.datasets[datasetIndex];

        if (!dataset) return;

        let sessionId = dataset.label;
        let sessionTrackPoints = trackPoints[sessionId];

        if (!sessionTrackPoints) {
            if (sessionId.includes('_') && sessionId !== 'GPX Track') {
                const parts = sessionId.split('_');
                if (parts.length > 1) {
                    const extractedId = parts.slice(1).join('_');
                    sessionTrackPoints = trackPoints[extractedId];
                    if (sessionTrackPoints) {
                        sessionId = extractedId;
                    }
                }
            }
        }

        if (!sessionTrackPoints) {
            const availableKeys = Object.keys(trackPoints);
            for (const key of availableKeys) {
                if (key.includes(sessionId) || sessionId.includes(key)) {
                    sessionTrackPoints = trackPoints[key];
                    sessionId = key;
                    break;
                }
            }

            if (!sessionTrackPoints) return;
        }

        if (!sessionTrackPoints[dataIndex]) return;

        const point = sessionTrackPoints[dataIndex];

        map.setView([point.lat, point.lng], Math.max(map.getZoom(), 15));

        addDebugMessage(`Chart click - Centered map on Session: ${sessionId}, Point: ${dataIndex}`, 'interaction');
    }

    function showHoverMarker(lat, lng, sessionId) {
        if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
            addDebugMessage(`Invalid coordinates for hover marker: ${lat}, ${lng}`, 'error');
            return;
        }

        if (hoverMarker) {
            map.removeLayer(hoverMarker);
        }

        const sessionColor = getColorForUser(sessionId);

        try {
            hoverMarker = L.circleMarker([lat, lng], {
                radius: 10,
                fillColor: sessionColor,
                color: '#fff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);

            addDebugMessage(`Hover marker created at ${lat}, ${lng} with color ${sessionColor}`, 'interaction');
        } catch (error) {
            addDebugMessage(`Error creating hover marker: ${error.message}`, 'error');
        }
    }

    function hideHoverMarker() {
        if (hoverMarker) {
            map.removeLayer(hoverMarker);
            hoverMarker = null;
        }
    }

    function hideInfoPopup() {
        if (infoPopup) {
            infoPopup.style.display = 'none';
            infoPopup.classList.remove('popup-visible');
        }
    }

    function getWeatherDescription(weatherCode) {
        const weatherCodes = {
            0: "Clear sky",
            1: "Mainly clear",
            2: "Partly cloudy",
            3: "Overcast",
            45: "Fog",
            48: "Depositing rime fog",
            51: "Light drizzle",
            53: "Moderate drizzle",
            55: "Dense drizzle",
            61: "Slight rain",
            63: "Moderate rain",
            65: "Heavy rain",
            71: "Slight snow",
            73: "Moderate snow",
            75: "Heavy snow",
            77: "Snow grains",
            80: "Slight rain showers",
            81: "Moderate rain showers",
            82: "Violent rain showers",
            85: "Slight snow showers",
            86: "Heavy snow showers",
            95: "Thunderstorm",
            96: "Thunderstorm with hail",
            99: "Thunderstorm with heavy hail"
        };

        return weatherCodes[weatherCode] || `Code ${weatherCode}`;
    }

    function getWindDirectionText(degrees) {
        if (degrees === undefined || degrees === null || degrees === 0) {
            return 'N/A';
        }

        const deg = parseFloat(degrees);
        if (isNaN(deg)) {
            return 'N/A';
        }

        const directions = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE",
                           "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"];

        const normalizedDeg = ((deg % 360) + 360) % 360;
        const index = Math.round(normalizedDeg / 22.5) % 16;

        return `${directions[index]} (${normalizedDeg.toFixed(0)}¬∞)`;
    }

    function formatWeatherTime(weatherTime) {
        if (!weatherTime) return "N/A";

        try {
            const date = new Date(weatherTime);
            return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        } catch (e) {
            return weatherTime;
        }
    }

    function getWeatherEmoji(weatherCode) {
        const weatherEmojis = {
            0: "‚òÄÔ∏è",   1: "üå§Ô∏è",   2: "‚õÖ",   3: "‚òÅÔ∏è",   45: "üå´Ô∏è",  48: "üå´Ô∏è",
            51: "üå¶Ô∏è",  53: "üå¶Ô∏è",  55: "üåßÔ∏è",  61: "üåßÔ∏è",  63: "üåßÔ∏è",  65: "‚õàÔ∏è",
            71: "üå®Ô∏è",  73: "‚ùÑÔ∏è",  75: "‚ùÑÔ∏è",  77: "‚ùÑÔ∏è",  80: "üå¶Ô∏è",  81: "üåßÔ∏è",
            82: "‚õàÔ∏è",  85: "üå®Ô∏è",  86: "‚ùÑÔ∏è",  95: "‚õàÔ∏è",  96: "‚õàÔ∏è",  99: "‚õàÔ∏è"
        };

        return weatherEmojis[weatherCode] || "üå§Ô∏è";
    }

    function showInfoPopup(event, point, sessionId, chartType) {
        console.log('üñºÔ∏è showInfoPopup called:', {
            hasPopup: !!infoPopup,
            hasEvent: !!event,
            hasPoint: !!point,
            sessionId,
            chartType
        });

        if (!infoPopup) {
            console.error('‚ùå Info popup element not found!');
            addDebugMessage('Info popup element not found', 'error');
            createInfoPopup();
            if (!infoPopup) {
                console.error('‚ùå Failed to recreate popup');
                return;
            }
        }

        try {
            const personName = sessionPersonNames[sessionId] || "";
            let displayId = sessionId;
            if (personName) {
                displayId = createDisplayId(sessionId, personName);
            }

            const timeStr = point.timestamp ? point.timestamp.toLocaleTimeString() : 'N/A';
            const dateStr = point.timestamp ? point.timestamp.toLocaleDateString() : 'N/A';
            const isGPXTrack = sessionId === 'GPX Track';

            let additionalInfo = '';
            if (isGPXTrack && point.lap !== undefined && point.activityType) {
                additionalInfo = `
                    <div style="border-bottom: 1px solid #ddd; margin-bottom: 6px; padding-bottom: 4px;">
                        <strong>Activity:</strong> ${point.activityType}<br>
                        <strong>Lap:</strong> ${point.lap}
                    </div>
                `;
            }

            const weatherData = extractWeatherData(point);
            const barometerData = extractBarometerData(point);

            let weatherSection = '';

            if (weatherData.hasData || barometerData.hasData) {
                const weatherDescription = getWeatherDescription(weatherData.weatherCode || 0);
                const weatherEmoji = getWeatherEmoji(weatherData.weatherCode || 0);
                const windDirectionText = getWindDirectionText(weatherData.windDirection || 0);
                const weatherTimeFormatted = formatWeatherTime(weatherData.weatherTime);

                weatherSection = `
                    <div class="weather-section" style="background-color: #f8f9fa; border-radius: 4px; padding: 8px; margin: 8px 0; border-left: 3px solid #FF5722;">
                        <div class="weather-header" style="font-weight: bold; color: #FF5722; margin-bottom: 6px; display: flex; align-items: center; gap: 4px; font-size: 11px;">
                            ${weatherEmoji} Weather & Atmospheric Conditions
                        </div>
                        <div class="weather-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 10px;">
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #FF5722;">Temperature</div>
                                <div class="weather-value temperature" style="color: #FF5722; font-weight: bold; font-size: 11px;">
                                    ${weatherData.temperature ? weatherData.temperature.toFixed(1) + '¬∞C' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #2196F3;">Humidity</div>
                                <div class="weather-value humidity" style="color: #2196F3; font-weight: bold; font-size: 11px;">
                                    ${weatherData.humidity ? weatherData.humidity + '%' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #795548;">Wind Speed</div>
                                <div class="weather-value wind" style="color: #795548; font-weight: bold; font-size: 11px;">
                                    ${weatherData.windSpeed ? weatherData.windSpeed.toFixed(1) + ' km/h' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #795548;">Wind Dir</div>
                                <div class="weather-value wind" style="color: #795548; font-weight: bold; font-size: 11px;">
                                    ${windDirectionText}
                                </div>
                            </div>`;

                if (barometerData.hasData) {
                    weatherSection += `
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #9C27B0;">Pressure</div>
                                <div class="weather-value pressure" style="color: #9C27B0; font-weight: bold; font-size: 11px;">
                                    ${barometerData.pressure ? barometerData.pressure.toFixed(1) + ' hPa' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #9C27B0;">Sea Level</div>
                                <div class="weather-value pressure" style="color: #9C27B0; font-weight: bold; font-size: 11px;">
                                    ${barometerData.seaLevelPressure ? barometerData.seaLevelPressure.toFixed(1) + ' hPa' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #607D8B;">Baro Alt</div>
                                <div class="weather-value barometer" style="color: #607D8B; font-weight: bold; font-size: 11px;">
                                    ${barometerData.altitudeFromPressure ? barometerData.altitudeFromPressure.toFixed(1) + ' m' : 'N/A'}
                                </div>
                            </div>
                            <div class="weather-item" style="text-align: center;">
                                <div class="weather-label" style="font-weight: bold; margin-bottom: 2px; color: #607D8B;">Accuracy</div>
                                <div class="weather-value barometer" style="color: #607D8B; font-weight: bold; font-size: 11px;">
                                    ${barometerData.pressureAccuracy ? barometerData.pressureAccuracy + ' Pa' : 'N/A'}
                                </div>
                            </div>`;
                }

                weatherSection += `
                        </div>
                        ${weatherDescription !== 'Code 0' ? `
                            <div class="weather-footer" style="margin-top: 6px; font-size: 9px; color: #666; font-style: italic; text-align: center;">
                                ${weatherDescription} ‚Ä¢ ${weatherTimeFormatted}
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            const content = `
                <div style="font-weight: bold; color: ${isGPXTrack ? 'red' : getColorForUser(sessionId)}; margin-bottom: 8px;">
                    ${displayId}
                </div>
                <div style="border-bottom: 1px solid #ddd; margin-bottom: 6px; padding-bottom: 4px;">
                    <strong>Time:</strong> ${timeStr}<br>
                    <strong>Date:</strong> ${dateStr}
                </div>
                ${additionalInfo}
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                    <div>
                        <strong style="color: #2196F3;">Distance</strong><br>
                        ${point.distance.toFixed(2)} km
                    </div>
                    <div>
                        <strong style="color: #4CAF50;">Altitude</strong><br>
                        ${point.altitude.toFixed(1)} m
                    </div>
                    <div>
                        <strong style="color: #FF9800;">Speed</strong><br>
                        ${point.speed.toFixed(1)} km/h
                    </div>
                    <div>
                        <strong style="color: ${getHeartRateColor(point.heartRate || 0)};">Heart Rate</strong><br>
                        ${point.heartRate || 0} bpm
                    </div>
                </div>
                ${weatherSection}
                <div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid #ddd; font-size: 10px; color: #666;">
                    Coordinates: ${point.lat.toFixed(6)}, ${point.lng.toFixed(6)}
                </div>
                ${isGPXTrack ? '<div style="font-size: 9px; color: #999; margin-top: 4px;">üìÅ GPX File Data</div>' : ''}
            `;

            infoPopup.innerHTML = content;

            let x, y;
            if (event.native) {
                x = event.native.pageX || event.native.clientX + window.scrollX || 0;
                y = event.native.pageY || event.native.clientY + window.scrollY || 0;
            } else {
                x = event.pageX || event.clientX + window.scrollX || 0;
                y = event.pageY || event.clientY + window.scrollY || 0;
            }

            const finalX = Math.max(10, Math.min(x + 15, window.innerWidth - 420));
            const finalY = Math.max(10, Math.min(y - 10, window.innerHeight - 350));

            infoPopup.style.left = finalX + 'px';
            infoPopup.style.top = finalY + 'px';
            infoPopup.style.display = 'block';
            infoPopup.classList.add('popup-visible');

            console.log('‚úÖ Popup with weather and barometer data displayed at:', finalX, finalY);
            addDebugMessage(`Info popup with weather and barometer data shown at coordinates: ${finalX}, ${finalY}`, 'interaction');

            setTimeout(() => {
                const popupRect = infoPopup.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;

                let newX = finalX;
                let newY = finalY;

                if (popupRect.right > windowWidth) {
                    newX = x - popupRect.width - 15;
                }
                if (popupRect.bottom > windowHeight) {
                    newY = y - popupRect.height + 10;
                }

                if (newX !== finalX || newY !== finalY) {
                    infoPopup.style.left = newX + 'px';
                    infoPopup.style.top = newY + 'px';
                    console.log('üìê Popup repositioned to:', newX, newY);
                }
            }, 1);

        } catch (error) {
            console.error('‚ùå Error in showInfoPopup:', error);
            addDebugMessage(`Popup error: ${error.message}`, 'error');
        }
    }

    function extractWeatherData(point) {
        const hasTemperature = point.temperature !== undefined && point.temperature !== null && point.temperature > 0;
        const hasWindSpeed = point.windSpeed !== undefined && point.windSpeed !== null && point.windSpeed > 0;
        const hasHumidity = point.relativeHumidity !== undefined && point.relativeHumidity !== null && point.relativeHumidity > 0;
        const hasWeatherCode = point.weatherCode !== undefined && point.weatherCode !== null && point.weatherCode > 0;
        const hasWindDirection = point.windDirection !== undefined && point.windDirection !== null;

        return {
            hasData: hasTemperature || hasWindSpeed || hasHumidity || hasWeatherCode || hasWindDirection,
            temperature: hasTemperature ? point.temperature : null,
            windSpeed: hasWindSpeed ? point.windSpeed : null,
            windDirection: hasWindDirection ? point.windDirection : null,
            humidity: hasHumidity ? point.relativeHumidity : null,
            weatherCode: hasWeatherCode ? point.weatherCode : null,
            weatherTime: point.weatherTime || ""
        };
    }

    function extractBarometerData(point) {
        const hasPressure = point.pressure !== undefined && point.pressure !== null && point.pressure > 0;
        const hasAltitudeFromPressure = point.altitudeFromPressure !== undefined && point.altitudeFromPressure !== null;
        const hasSeaLevelPressure = point.seaLevelPressure !== undefined && point.seaLevelPressure !== null && point.seaLevelPressure > 0;
        const hasPressureAccuracy = point.pressureAccuracy !== undefined && point.pressureAccuracy !== null;

        return {
            hasData: hasPressure || hasAltitudeFromPressure || hasSeaLevelPressure || hasPressureAccuracy,
            pressure: hasPressure ? point.pressure : null,
            altitudeFromPressure: hasAltitudeFromPressure ? point.altitudeFromPressure : null,
            seaLevelPressure: hasSeaLevelPressure ? point.seaLevelPressure : null,
            pressureAccuracy: hasPressureAccuracy ? point.pressureAccuracy : null
        };
    }

    function testChartSetup() {
        console.log('üß™ Testing chart setup...');

        const tests = {
            altitudeChart: !!altitudeChart,
            speedChart: !!speedChart,
            infoPopup: !!infoPopup,
            altitudeCanvas: !!document.getElementById('altitudeChart'),
            speedCanvas: !!document.getElementById('speedChart'),
            trackPointsCount: Object.keys(trackPoints).length
        };

        console.log('üß™ Chart setup test results:', tests);
        addDebugMessage(`Chart setup test: ${JSON.stringify(tests)}`, 'system');

        if (altitudeChart && altitudeChart.options && altitudeChart.options.onHover) {
            console.log('‚úÖ Altitude chart hover handler is bound');
        } else {
            console.log('‚ùå Altitude chart hover handler NOT bound');
        }

        if (speedChart && speedChart.options && speedChart.options.onHover) {
            console.log('‚úÖ Speed chart hover handler is bound');
        } else {
            console.log('‚ùå Speed chart hover handler NOT bound');
        }
    }

    function toggleStatBoxes() {
        const speedDisplay = document.getElementById('speedDisplay');
        const toggleBtn = document.getElementById('toggleStatsBtn');

        if (statsVisible) {
            speedDisplay.style.display = 'none';
            toggleBtn.textContent = 'Show Stats';
            statsVisible = false;
        } else {
            speedDisplay.style.display = 'block';
            toggleBtn.textContent = 'Hide Stats';
            statsVisible = true;
        }

        addDebugMessage(`Stats visibility toggled: ${statsVisible ? 'shown' : 'hidden'}`, 'system');
    }

    function handleLegendClick(e, legendItem, legend) {
        const index = legendItem.datasetIndex;
        const displayId = legend.chart.data.datasets[index].label;
        const isVisible = legend.chart.isDatasetVisible(index);

        const sessionId = extractSessionIdFromDisplayId(displayId);

        addDebugMessage(`Toggle visibility from legend click: ${displayId} (Session ID: ${sessionId})`, 'ui');

        [altitudeChart, speedChart].forEach(chart => {
            chart.data.datasets.forEach((dataset, i) => {
                if (dataset.label === displayId) {
                    chart.setDatasetVisibility(i, !isVisible);
                }
            });
            chart.update();
        });

        toggleMapElementsVisibility(sessionId, !isVisible);
    }

    function extractSessionIdFromDisplayId(displayId) {
        if (displayId.includes('_')) {
            return displayId.split('_').slice(1).join('_');
        }
        return displayId;
    }

    function toggleMapElementsVisibility(sessionId, visible) {
        addDebugMessage(`Toggling map visibility for session ${sessionId} to ${visible ? 'visible' : 'hidden'}`, 'map');

        if (polylines[sessionId]) {
            if (visible) {
                if (!map.hasLayer(polylines[sessionId])) {
                    map.addLayer(polylines[sessionId]);
                }
            } else {
                if (map.hasLayer(polylines[sessionId])) {
                    map.removeLayer(polylines[sessionId]);
                }
            }
        } else {
            addDebugMessage(`No polyline found for session ${sessionId}`, 'warning');
        }

        [startMarkers, endMarkers].forEach(markers => {
            if (markers[sessionId]) {
                if (visible) {
                    if (!map.hasLayer(markers[sessionId])) {
                        map.addLayer(markers[sessionId]);
                    }
                } else {
                    if (map.hasLayer(markers[sessionId])) {
                        map.removeLayer(markers[sessionId]);
                    }
                }
            }
        });

        const speedContainer = document.getElementById(`speed-container-${sessionId}`);
        if (speedContainer) {
            speedContainer.style.display = visible ? 'block' : 'none';
        }
    }

    function connectToWebSocket() {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/geotracker`;

        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
            console.log('Connected to WebSocket server');
            addDebugMessage('WebSocket connection established', 'connection');
            requestSessionList();
        };

        websocket.onmessage = (event) => {
            const message = JSON.parse(event.data);

            addDebugMessage(JSON.stringify(message, null, 2), message.type);

            if (message.type === 'update' && message.point) {
                logWeatherData(message.point);
            } else if (message.type === 'history_batch' && message.points) {
                if (message.points.length > 0) {
                    logWeatherData(message.points[0]);
                }
            }

            switch (message.type) {
                case 'history_batch':
                    handleHistoryBatch(message.points);
                    break;
                case 'history_complete':
                    finalizeBatchProcessing();
                    break;
                case 'update':
                    handlePoint(message.point);
                    break;
                case 'invalid_coordinates':
                    handleInvalidCoordinates(message);
                    break;
                case 'session_list':
                    handleSessionList(message.sessions);
                    break;
            }
        };

        websocket.onclose = () => {
            console.log('WebSocket connection closed');
            addDebugMessage('WebSocket connection closed', 'connection');
            setTimeout(connectToWebSocket, 5000);
        };

        websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            addDebugMessage('WebSocket error: ' + error, 'error');
        };
    }

    function handleInvalidCoordinates(message) {
        const sessionId = message.sessionId;
        const reason = message.reason || 'Invalid GPS coordinates';
        const otherData = message.otherData || {};

        addDebugMessage(`Invalid coordinates for session ${sessionId}: ${reason}`, 'warning');

        if (otherData.currentSpeed !== undefined) {
            const speedContainer = document.getElementById(`speed-container-${sessionId}`);
            if (speedContainer) {
                const currentSpeedElement = document.getElementById(`currentSpeed-${sessionId}`);
                if (currentSpeedElement) {
                    currentSpeedElement.textContent = parseFloat(otherData.currentSpeed || 0).toFixed(1);
                    currentSpeedElement.style.color = getSpeedColor(parseFloat(otherData.currentSpeed || 0));
                }

                if (otherData.heartRate !== undefined) {
                    const heartRateElement = document.getElementById(`heartRate-${sessionId}`);
                    if (heartRateElement) {
                        heartRateElement.textContent = otherData.heartRate;
                        heartRateElement.style.color = getHeartRateColor(otherData.heartRate);
                    }
                }
            }
        }

        showNotification(`GPS signal lost for ${sessionPersonNames[sessionId] || sessionId}: ${reason}`, 'warning');
    }

    function handleHistoryBatch(points) {
        if (!points || points.length === 0) return;

        console.log('üì¶ Processing history batch:', points.length, 'points');

        isProcessingBatch = true;

        points.forEach(point => {
            const sessionId = point.sessionId || "default";
            const personName = point.person || "";

            if (personName) {
                sessionPersonNames[sessionId] = personName;
            }

            if (!trackPoints[sessionId]) {
                trackPoints[sessionId] = [];
            }

            const processedPoint = {
                lat: parseFloat(point.latitude),
                lng: parseFloat(point.longitude),
                distance: parseFloat(point.distance) / 1000,
                altitude: parseFloat(point.altitude || 0),
                speed: parseFloat(point.currentSpeed || 0),
                averageSpeed: parseFloat(point.averageSpeed || 0),
                cumulativeElevationGain: parseFloat(point.cumulativeElevationGain || 0),
                heartRate: parseInt(point.heartRate || 0),
                timestamp: new Date(point.timestamp.replace(/(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1')),
                personName: personName,

                temperature: parseFloat(point.temperature || 0),
                windSpeed: parseFloat(point.windSpeed || 0),
                windDirection: parseFloat(point.windDirection || 0),
                relativeHumidity: parseInt(point.relativeHumidity || point.humidity || 0),
                weatherCode: parseInt(point.weatherCode || 0),
                weatherTime: point.weatherTime || "",

                pressure: parseFloat(point.pressure || 0),
                altitudeFromPressure: parseFloat(point.altitudeFromPressure || 0),
                seaLevelPressure: parseFloat(point.seaLevelPressure || 0),
                pressureAccuracy: parseInt(point.pressureAccuracy || 0)
            };

            console.log('üå§Ô∏è Processed point weather & barometer data:', {
                sessionId,
                temperature: processedPoint.temperature,
                windSpeed: processedPoint.windSpeed,
                pressure: processedPoint.pressure,
                altitudeFromPressure: processedPoint.altitudeFromPressure
            });

            validateWeatherData(processedPoint);
            updateWeatherStats(processedPoint);

            trackPoints[sessionId].push(processedPoint);
        });
    }

    function finalizeBatchProcessing() {
        if (!isProcessingBatch) return;

        Object.keys(trackPoints).forEach(sessionId => {
            trackPoints[sessionId].sort((a, b) => a.timestamp - b.timestamp);
        });

        requestAnimationFrame(() => {
            Object.keys(trackPoints).forEach(sessionId => {
                if (shouldDisplaySession(sessionId)) {
                    updateMapTrack(sessionId);
                    updateCharts(sessionId);

                    const latestPoint = trackPoints[sessionId][trackPoints[sessionId].length - 1];
                    if (latestPoint) {
                        updateSpeedDisplay(sessionId, latestPoint.speed, {
                            averageSpeed: latestPoint.averageSpeed,
                            cumulativeElevationGain: latestPoint.cumulativeElevationGain,
                            heartRate: latestPoint.heartRate,
                            distance: latestPoint.distance,
                            personName: latestPoint.personName ||
                                (window.sessionPersonNames && window.sessionPersonNames[sessionId]) || "",
                            weather: {
                                temperature: latestPoint.temperature,
                                windSpeed: latestPoint.windSpeed,
                                windDirection: latestPoint.windDirection,
                                relativeHumidity: latestPoint.relativeHumidity,
                                weatherCode: latestPoint.weatherCode,
                                weatherTime: latestPoint.weatherTime
                            }
                        });
                    }
                } else {
                    addDebugMessage(`Skipping visualization update for filtered session: ${sessionId}`, 'system');
                }
            });
            isProcessingBatch = false;
        });
    }

    function handlePoint(data) {
        if (!data || isProcessingBatch) return;

        const sessionId = data.sessionId || "default";
        const personName = data.person || "";

        if (personName) {
            sessionPersonNames[sessionId] = personName;
        }

        const processedPoint = {
            lat: parseFloat(data.latitude),
            lng: parseFloat(data.longitude),
            distance: parseFloat(data.distance) / 1000,
            altitude: parseFloat(data.altitude || 0),
            speed: parseFloat(data.currentSpeed || 0),
            averageSpeed: parseFloat(data.averageSpeed || 0),
            maxSpeed: parseFloat(data.maxSpeed || 0),
            movingAverageSpeed: parseFloat(data.movingAverageSpeed || 0),
            cumulativeElevationGain: parseFloat(data.cumulativeElevationGain || 0),
            heartRate: parseInt(data.heartRate || 0),
            timestamp: new Date(data.timestamp.replace(/(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1')),
            personName: personName,

            temperature: parseFloat(data.temperature || 0),
            windSpeed: parseFloat(data.windSpeed || 0),
            windDirection: parseFloat(data.windDirection || 0),
            relativeHumidity: parseInt(data.relativeHumidity || 0),
            weatherCode: parseInt(data.weatherCode || 0),
            weatherTime: data.weatherTime || "",

            pressure: parseFloat(data.pressure || 0),
            altitudeFromPressure: parseFloat(data.altitudeFromPressure || 0),
            seaLevelPressure: parseFloat(data.seaLevelPressure || 0),
            pressureAccuracy: parseInt(data.pressureAccuracy || 0)
        };

        validateWeatherData(processedPoint);
        updateWeatherStats(processedPoint);

        if (!trackPoints[sessionId]) {
            trackPoints[sessionId] = [];
        }

        trackPoints[sessionId].push(processedPoint);

        clearGPSWarnings(sessionId);

        requestAnimationFrame(() => {
            updateMapTrack(sessionId);
            updateCharts(sessionId);
            updateSpeedDisplay(sessionId, processedPoint.speed, {
                averageSpeed: processedPoint.averageSpeed,
                maxSpeed: processedPoint.maxSpeed,
                movingAverageSpeed: processedPoint.movingAverageSpeed,
                cumulativeElevationGain: processedPoint.cumulativeElevationGain,
                heartRate: processedPoint.heartRate,
                distance: processedPoint.distance,
                personName: processedPoint.personName,
                weather: {
                    temperature: processedPoint.temperature,
                    windSpeed: processedPoint.windSpeed,
                    windDirection: processedPoint.windDirection,
                    relativeHumidity: processedPoint.relativeHumidity,
                    weatherCode: processedPoint.weatherCode,
                    weatherTime: processedPoint.weatherTime
                },
                barometer: {
                    pressure: processedPoint.pressure,
                    altitudeFromPressure: processedPoint.altitudeFromPressure,
                    seaLevelPressure: processedPoint.seaLevelPressure,
                    pressureAccuracy: processedPoint.pressureAccuracy
                }
            });
        });
    }

    function clearGPSWarnings(sessionId) {
        const speedContainer = document.getElementById(`speed-container-${sessionId}`);
        if (speedContainer) {
            const gpsIndicator = speedContainer.querySelector('.gps-status');
            if (gpsIndicator) {
                gpsIndicator.style.backgroundColor = '#44ff44';
                gpsIndicator.title = 'GPS signal restored';
                setTimeout(() => {
                    if (gpsIndicator && gpsIndicator.parentNode) {
                        gpsIndicator.remove();
                    }
                }, 2000);
            }
        }
    }

    function updateMapTrack(sessionId) {
        const points = trackPoints[sessionId];
        if (!points || points.length === 0) return;

        if (polylines[sessionId]) {
            map.removeLayer(polylines[sessionId]);
        }
        if (startMarkers[sessionId]) {
            map.removeLayer(startMarkers[sessionId]);
        }
        if (endMarkers[sessionId]) {
            map.removeLayer(endMarkers[sessionId]);
        }

        const coordinates = points.map(point => [point.lat, point.lng]);
        const userColor = getColorForUser(sessionId);

        polylines[sessionId] = L.polyline(coordinates, {
            color: userColor,
            weight: 3
        }).addTo(map);

        startMarkers[sessionId] = L.marker(coordinates[0], {
            title: "Start Position - " + sessionId
        }).bindPopup('Start - ' + sessionId).addTo(map);

        endMarkers[sessionId] = L.marker(coordinates[coordinates.length - 1], {
            title: "Current Position - " + sessionId
        }).bindPopup('Current - ' + sessionId).addTo(map);
    }

    function updateCharts(sessionId) {
        if (!shouldDisplaySession(sessionId)) {
            addDebugMessage(`Skipping chart update for filtered session: ${sessionId}`, 'system');
            return;
        }

        const points = trackPoints[sessionId];
        if (!points || points.length === 0) return;

        const personName = sessionPersonNames[sessionId] || "";
        const displayId = createDisplayId(sessionId, personName);

        const chartData = points.map(point => ({
            x: point.distance,
            y: point.altitude
        }));

        const speedData = points.map(point => ({
            x: point.distance,
            y: point.speed
        }));

        let altDatasetIndex = altitudeChart.data.datasets.findIndex(
            dataset => dataset.label === sessionId || dataset.label === displayId
        );

        if (altDatasetIndex === -1) {
            altDatasetIndex = altitudeChart.data.datasets.length;
            altitudeChart.data.datasets.push({
                label: displayId,
                borderColor: getColorForUser(sessionId),
                fill: false,
                data: []
            });
        } else if (personName && altitudeChart.data.datasets[altDatasetIndex].label !== displayId) {
            altitudeChart.data.datasets[altDatasetIndex].label = displayId;
        }

        altitudeChart.data.datasets[altDatasetIndex].data = chartData;

        let speedDatasetIndex = speedChart.data.datasets.findIndex(
            dataset => dataset.label === sessionId || dataset.label === displayId
        );

        if (speedDatasetIndex === -1) {
            speedDatasetIndex = speedChart.data.datasets.length;
            speedChart.data.datasets.push({
                label: displayId,
                borderColor: getColorForUser(sessionId),
                fill: false,
                data: []
            });
        } else if (personName && speedChart.data.datasets[speedDatasetIndex].label !== displayId) {
            speedChart.data.datasets[speedDatasetIndex].label = displayId;
        }

        speedChart.data.datasets[speedDatasetIndex].data = speedData;

        requestAnimationFrame(() => {
            altitudeChart.update('none');
            speedChart.update('none');
        });
    }

    function getSpeedColor(speed) {
        if (speed < 5) return '#2196F3';
        if (speed < 10) return '#4CAF50';
        return '#F44336';
    }

    function getElevationColor(elevation) {
        if (elevation < 10) return '#2196F3';
        if (elevation < 50) return '#4CAF50';
        return '#F44336';
    }

    function getHeartRateColor(heartRate) {
        if (heartRate === 0) return '#999';
        if (heartRate < 60) return '#2196F3';
        if (heartRate < 100) return '#4CAF50';
        if (heartRate < 140) return '#FF9800';
        return '#F44336';
    }

    function updateSpeedDisplay(sessionId, speed, data) {
        if (!shouldDisplaySession(sessionId)) {
            addDebugMessage(`Skipping speed display update for filtered session: ${sessionId}`, 'system');
            return;
        }

        const personName = data.personName || sessionPersonNames[sessionId] || "";
        const displayId = createDisplayId(sessionId, personName);

        if (!speedHistory[sessionId]) {
            speedHistory[sessionId] = {
                speeds: [],
                maxSpeed: 0,
                avgSpeed: 0,
                movingAvg: 0,
                elevationGain: 0,
                heartRate: 0,
                totalDistance: 0,
                lastUpdate: new Date(),
                personName: personName
            };
        } else if (personName && !speedHistory[sessionId].personName) {
            speedHistory[sessionId].personName = personName;
        }

        const history = speedHistory[sessionId];
        history.speeds.push(speed);
        history.lastUpdate = new Date();

        if (!statsVisible && document.getElementById('speedDisplay').style.display === 'none') {
            if (data.maxSpeed !== undefined) {
                history.maxSpeed = Math.max(history.maxSpeed, data.maxSpeed);
            }

            if (data.cumulativeElevationGain !== undefined) {
                history.elevationGain = data.cumulativeElevationGain;
            }

            if (data.heartRate !== undefined) {
                history.heartRate = data.heartRate;
            }

            if (data.distance !== undefined) {
                history.totalDistance = data.distance;
            }

            cleanupOldSessions();
            return;
        }

        const speedDisplay = document.getElementById('speedDisplay');

        const defaultDisplay = speedDisplay.querySelector('.stats-grid:not([id^="speed-grid-"])');
        if (defaultDisplay) {
            defaultDisplay.remove();
            console.log("Removed default display when handling session: " + sessionId);
        }

        let speedContainer = document.getElementById(`speed-container-${sessionId}`);

        if (!speedContainer) {
            speedContainer = document.createElement('div');
            speedContainer.id = `speed-container-${sessionId}`;
            speedContainer.className = 'session-container';

            const statsGrid = document.createElement('div');
            statsGrid.id = `speed-grid-${sessionId}`;
            statsGrid.className = 'stats-grid';

            const sessionLabel = document.createElement('div');
            sessionLabel.className = 'session-label';
            sessionLabel.textContent = displayId;

            speedContainer.appendChild(sessionLabel);
            speedContainer.appendChild(statsGrid);

            speedDisplay.appendChild(speedContainer);

            statsGrid.innerHTML = `
                <div class="stat-box">
                    <div class="speed-label">Current Speed</div>
                    <div class="speed-value" id="currentSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Maximum Speed</div>
                    <div class="speed-value" id="maxSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Average Speed</div>
                    <div class="speed-value" id="avgSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Moving Average</div>
                    <div class="speed-value" id="movingAvg-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="elevation-label">Elevation Gain</div>
                    <div class="elevation-value" id="elevationGain-${sessionId}">0.0</div>
                    <div class="elevation-unit">m</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Distance</div>
                    <div class="elevation-value" id="totalDistance-${sessionId}">0.0</div>
                    <div class="elevation-unit">km</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Heart Rate</div>
                    <div class="speed-value" id="heartRate-${sessionId}">0</div>
                    <div class="speed-unit">bpm</div>
                </div>
            `;

            speedDisplay.scrollTop = speedDisplay.scrollHeight;
        } else {
            const sessionLabel = speedContainer.querySelector('.session-label');
            if (sessionLabel && personName) {
                sessionLabel.textContent = displayId;
            }
        }

        const currentSpeedElement = document.getElementById(`currentSpeed-${sessionId}`);
        if (currentSpeedElement) {
            currentSpeedElement.textContent = speed.toFixed(1);
            currentSpeedElement.style.color = getSpeedColor(speed);
        }

        const maxSpeedElement = document.getElementById(`maxSpeed-${sessionId}`);
        if (maxSpeedElement && data.maxSpeed !== undefined) {
            history.maxSpeed = Math.max(history.maxSpeed, data.maxSpeed);
            maxSpeedElement.textContent = history.maxSpeed.toFixed(1);
            maxSpeedElement.style.color = getSpeedColor(history.maxSpeed);
        }

        const avgSpeedElement = document.getElementById(`avgSpeed-${sessionId}`);
        if (avgSpeedElement && data.averageSpeed !== undefined) {
            avgSpeedElement.textContent = data.averageSpeed.toFixed(1);
            avgSpeedElement.style.color = getSpeedColor(data.averageSpeed);
        }

        const movingAvgElement = document.getElementById(`movingAvg-${sessionId}`);
        if (movingAvgElement && data.movingAverageSpeed !== undefined) {
            movingAvgElement.textContent = data.movingAverageSpeed.toFixed(1);
            movingAvgElement.style.color = getSpeedColor(data.movingAverageSpeed);
        }

        const elevationGainElement = document.getElementById(`elevationGain-${sessionId}`);
        if (elevationGainElement && data.cumulativeElevationGain !== undefined) {
            history.elevationGain = data.cumulativeElevationGain;
            elevationGainElement.textContent = history.elevationGain.toFixed(1);
            elevationGainElement.style.color = getElevationColor(history.elevationGain);
        }

        const totalDistanceElement = document.getElementById(`totalDistance-${sessionId}`);
        if (totalDistanceElement && data.distance !== undefined) {
            history.totalDistance = data.distance;
            totalDistanceElement.textContent = history.totalDistance.toFixed(2);
            totalDistanceElement.style.color = getDistanceColor(history.totalDistance);
        }

        const heartRateElement = document.getElementById(`heartRate-${sessionId}`);
        if (heartRateElement && data.heartRate !== undefined) {
            history.heartRate = data.heartRate;
            heartRateElement.textContent = history.heartRate;
            heartRateElement.style.color = getHeartRateColor(history.heartRate);
        }

        cleanupOldSessions();
    }

    function getDistanceColor(distance) {
        if (distance < 1) return '#2196F3';
        if (distance < 5) return '#4CAF50';
        return '#FF9800';
    }

    function cleanupOldSessions() {
        const now = new Date();
        for (const sessionId in speedHistory) {
            const timeDiff = now - speedHistory[sessionId].lastUpdate;
            const shouldCleanup = timeDiff > 300000 || !shouldDisplaySession(sessionId);

            if (shouldCleanup) {
                const container = document.getElementById(`speed-container-${sessionId}`);
                if (container) {
                    container.remove();
                }
                delete speedHistory[sessionId];

                if (!shouldDisplaySession(sessionId)) {
                    addDebugMessage(`Cleaned up filtered session from speed display: ${sessionId}`, 'system');
                }
            }
        }
    }

    function getColorForUser(sessionId) {
        if (!userColors[sessionId]) {
            const ranges = [
                [150, 255, 0, 100, 0, 100],
                [0, 100, 150, 255, 0, 100],
                [0, 100, 0, 100, 150, 255],
                [150, 255, 150, 255, 0, 100],
                [150, 255, 0, 100, 150, 255],
                [0, 100, 150, 255, 150, 255]
            ];

            const hash = sessionId.split('').reduce((acc, char) => {
                return char.charCodeAt(0) + ((acc << 5) - acc);
            }, 0);

            const selectedRange = ranges[Math.abs(hash) % ranges.length];

            const r = getRandomInRange(selectedRange[0], selectedRange[1]);
            const g = getRandomInRange(selectedRange[2], selectedRange[3]);
            const b = getRandomInRange(selectedRange[4], selectedRange[5]);

            userColors[sessionId] = `rgb(${r}, ${g}, ${b})`;
        }
        return userColors[sessionId];
    }

    function createDisplayId(sessionId, personName) {
        if (!personName) return sessionId;

        if (sessionId.startsWith(personName + '_')) {
            return sessionId;
        } else {
            return `${personName}_${sessionId}`;
        }
    }

    function parseSessionId(sessionId) {
        const [name, timestamp] = sessionId.split('_');
        if (!timestamp) return { name: sessionId, timestamp: null };

        const year = timestamp.substr(0, 4);
        const month = timestamp.substr(4, 2);
        const day = timestamp.substr(6, 2);
        const hour = timestamp.substr(9, 2);
        const minute = timestamp.substr(11, 2);
        const second = timestamp.substr(13, 2);

        return {
            name: name,
            formattedTime: `${day}/${month}/${year} ${hour}:${minute}:${second}`
        };
    }

    function handleSessionList(sessions) {
        console.log("Raw sessions data:", sessions);
        addDebugMessage(`Raw sessions data: ${JSON.stringify(sessions)}`, 'debug');

        if (!Array.isArray(sessions)) {
            addDebugMessage('Sessions data not in expected format', 'error');
            return;
        }

        availableSessions = sessions;
        updateSessionList();

        addDebugMessage(`Processed ${sessions.length} sessions`, 'system');
    }

    function toggleSessionVisibility(sessionId) {
        addDebugMessage(`Toggle visibility requested for session ${sessionId}`, 'system');

        const personName = sessionPersonNames[sessionId] || "";
        const displayId = createDisplayId(sessionId, personName);

        let currentVisibility = null;

        const altDatasets = altitudeChart.data.datasets;
        for (let i = 0; i < altDatasets.length; i++) {
            if (altDatasets[i].label === displayId ||
                altDatasets[i].label.includes(sessionId)) {
                if (currentVisibility === null) {
                    currentVisibility = altitudeChart.isDatasetVisible(i);
                }
                altitudeChart.setDatasetVisibility(i, !currentVisibility);
            }
        }

        const speedDatasets = speedChart.data.datasets;
        for (let i = 0; i < speedDatasets.length; i++) {
            if (speedDatasets[i].label === displayId ||
                speedDatasets[i].label.includes(sessionId)) {
                speedChart.setDatasetVisibility(i, !currentVisibility);
            }
        }

        altitudeChart.update();
        speedChart.update();

        toggleMapElementsVisibility(sessionId, !currentVisibility);

        if (currentVisibility === null) {
            toggleMapElementsVisibility(sessionId, true);
            addDebugMessage(`No datasets found for session ${sessionId}, defaulting to visible`, 'warning');
        } else {
            addDebugMessage(`Toggled visibility of session ${sessionId} to ${!currentVisibility ? 'visible' : 'hidden'}`, 'system');
        }

        updateVisibilityButtonAppearance(sessionId, !currentVisibility);
    }

    function updateVisibilityButtonAppearance(sessionId, isVisible) {
        const sessionItem = document.querySelector(`[data-session-id="${sessionId}"]`);
        if (sessionItem) {
            const visibilityBtn = sessionItem.querySelector('.toggle-visibility');
            if (visibilityBtn) {
                visibilityBtn.innerHTML = isVisible ? 'üëÅ' : 'üëÅ‚Äçüó®';
                visibilityBtn.style.opacity = isVisible ? '1' : '0.5';
            }
        }
    }

    function zoomToSession(sessionId) {
        addDebugMessage(`Zoom to session requested: ${sessionId}`, 'system');

        const sessionTrackPoints = trackPoints[sessionId];
        if (!sessionTrackPoints || sessionTrackPoints.length === 0) {
            addDebugMessage(`No track points found for session ${sessionId}`, 'warning');
            showNotification(`No track data available for session ${sessionId}`, 'warning');
            return;
        }

        const coordinates = sessionTrackPoints.map(point => [point.lat, point.lng]);

        if (coordinates.length === 0) {
            addDebugMessage(`No valid coordinates found for session ${sessionId}`, 'warning');
            return;
        }

        try {
            const tempPolyline = L.polyline(coordinates);
            const bounds = tempPolyline.getBounds();

            map.fitBounds(bounds, {
                padding: [20, 20],
                maxZoom: 16
            });

            addDebugMessage(`Zoomed to session ${sessionId} - ${coordinates.length} points`, 'system');

            if (polylines[sessionId]) {
                const originalColor = polylines[sessionId].options.color;
                const originalWeight = polylines[sessionId].options.weight;

                polylines[sessionId].setStyle({ color: '#FF0000', weight: 6 });
                setTimeout(() => {
                    if (polylines[sessionId]) {
                        polylines[sessionId].setStyle({ color: originalColor, weight: originalWeight });
                    }
                }, 1000);
            }

        } catch (error) {
            addDebugMessage(`Error zooming to session ${sessionId}: ${error.message}`, 'error');
            showNotification(`Error zooming to session: ${error.message}`, 'warning');
        }
    }

    function updateSessionList() {
        const sessionsList = document.getElementById('sessionsList');

        if (!availableSessions || availableSessions.length === 0) {
            sessionsList.innerHTML = '<p class="no-sessions">No sessions found.</p>';
            return;
        }

        const filteredSessions = availableSessions.filter(session => {
            const sessionId = session.sessionId;
            return !sessionId.includes('_reset_') && !sessionId.includes('_archived_');
        });

        if (filteredSessions.length === 0) {
            sessionsList.innerHTML = '<p class="no-sessions">No primary sessions found.</p>';
            return;
        }

        let html = '';

        filteredSessions.forEach(session => {
            const sessionId = session.sessionId;
            const isActive = session.isActive;

            const parsedSession = parseSessionId(sessionId);
            const name = parsedSession.name;
            const time = parsedSession.formattedTime || 'Unknown time';
            const color = getColorForUser(sessionId);

            html += `
                <div class="session-item ${isActive ? 'active' : ''}" data-session-id="${sessionId}">
                    <div class="session-item-info">
                        <div class="session-item-name">
                            ${name}
                            ${isActive ? '<span class="active-badge" title="Active Session">‚ö°</span>' : ''}
                        </div>
                        <div class="session-item-time">${time}</div>
                    </div>
                    <div class="session-actions">
                        <button class="session-action-btn toggle-visibility"
                                onclick="toggleSessionVisibility('${sessionId}')"
                                title="Toggle Visibility">
                            üëÅ
                        </button>
                        <button class="session-action-btn zoom-to-session"
                                onclick="zoomToSession('${sessionId}')"
                                title="Zoom to Track">
                            üéØ
                        </button>
                    </div>
                </div>
            `;
        });

        sessionsList.innerHTML = html;

        addDebugMessage(`Session list updated: ${filteredSessions.length} primary sessions displayed (${availableSessions.length - filteredSessions.length} reset/archived sessions filtered out)`, 'system');
    }

    function confirmDeleteSession(sessionId) {
        const session = availableSessions.find(s => s.sessionId === sessionId);
        if (session && session.isActive) {
            showNotification('Cannot delete an active session. Wait for the session to complete first.', 'warning');
            addDebugMessage(`Attempted to delete active session: ${sessionId}`, 'warning');
            return;
        }

        const overlay = document.createElement('div');
        overlay.id = 'confirmOverlay';
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        overlay.style.zIndex = '2000';

        const dialog = document.createElement('div');
        dialog.className = 'confirm-delete';

        const parsedSession = parseSessionId(sessionId);

        dialog.innerHTML = `
            <h3>Delete Session</h3>
            <p>Are you sure you want to delete "${parsedSession.name}" session?</p>
            <p><strong>This action cannot be undone.</strong></p>
            <div class="confirm-buttons">
                <button class="confirm-btn cancel" onclick="closeConfirmDialog()">Cancel</button>
                <button class="confirm-btn delete" onclick="deleteSession('${sessionId}')">Delete</button>
            </div>
        `;

        document.body.appendChild(overlay);
        document.body.appendChild(dialog);

        addDebugMessage(`Showing delete confirmation for session ${sessionId}`, 'system');
    }

    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = message;

        Object.assign(notification.style, {
            position: 'fixed',
            top: '20px',
            right: '20px',
            padding: '12px 20px',
            backgroundColor: type === 'warning' ? '#ff9800' : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
            zIndex: '3000',
            fontFamily: 'Arial, sans-serif',
            fontSize: '14px',
            maxWidth: '300px'
        });

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transition = 'opacity 0.5s';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 500);
        }, 3000);
    }

    function toggleSessionPanel() {
        const panel = document.getElementById('sessionManagerPanel');
        const content = panel.querySelector('.panel-content');
        const toggleBtn = document.getElementById('toggleSessionPanel');

        if (sessionPanelVisible) {
            content.style.display = 'none';
            toggleBtn.textContent = '+';
        } else {
            content.style.display = 'block';
            toggleBtn.textContent = '-';
        }

        sessionPanelVisible = !sessionPanelVisible;
    }

    function requestSessionList() {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(JSON.stringify({
                type: 'request_sessions'
            }));

            addDebugMessage('Requested session list from server', 'system');
        } else {
            addDebugMessage('WebSocket not connected, cannot request sessions', 'error');
        }
    }

    function handleSessionDeleted(sessionId) {
        addDebugMessage(`Handling deletion of session ${sessionId}`, 'system');

        availableSessions = availableSessions.filter(session => session.sessionId !== sessionId);

        if (trackPoints[sessionId]) {
            delete trackPoints[sessionId];
        }

        if (speedHistory[sessionId]) {
            delete speedHistory[sessionId];
        }

        const altDatasets = altitudeChart.data.datasets;
        for (let i = altDatasets.length - 1; i >= 0; i--) {
            if (altDatasets[i].label.includes(sessionId)) {
                addDebugMessage(`Removing altitude dataset: ${altDatasets[i].label}`, 'system');
                altDatasets.splice(i, 1);
            }
        }
        altitudeChart.update();

        const speedDatasets = speedChart.data.datasets;
        for (let i = speedDatasets.length - 1; i >= 0; i--) {
            if (speedDatasets[i].label.includes(sessionId)) {
                addDebugMessage(`Removing speed dataset: ${speedDatasets[i].label}`, 'system');
                speedDatasets.splice(i, 1);
            }
        }
        speedChart.update();

        if (polylines[sessionId]) {
            map.removeLayer(polylines[sessionId]);
            delete polylines[sessionId];
        }

        if (startMarkers[sessionId]) {
            map.removeLayer(startMarkers[sessionId]);
            delete startMarkers[sessionId];
        }

        if (endMarkers[sessionId]) {
            map.removeLayer(endMarkers[sessionId]);
            delete endMarkers[sessionId];
        }

        const speedContainer = document.getElementById(`speed-container-${sessionId}`);
        if (speedContainer) {
            speedContainer.remove();
        }

        if (sessionPersonNames[sessionId]) {
            delete sessionPersonNames[sessionId];
        }

        updateSessionList();

        addDebugMessage(`Session ${sessionId} deleted and removed from all displays`, 'system');
        showNotification(`Session ${sessionId} deleted successfully`, 'info');
    }

    function deleteSession(sessionId) {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            const deleteRequest = {
                type: 'delete_session',
                sessionId: sessionId
            };

            console.log("Sending delete request:", deleteRequest);
            addDebugMessage(`Sending delete request: ${JSON.stringify(deleteRequest)}`, 'system');

            websocket.send(JSON.stringify(deleteRequest));
        } else {
            console.error("WebSocket not connected");
            addDebugMessage('WebSocket not connected, cannot delete session', 'error');
            showNotification('Cannot delete: Connection lost', 'warning');
        }

        closeConfirmDialog();
    }

    function closeConfirmDialog() {
        const overlay = document.getElementById('confirmOverlay');
        const dialog = document.querySelector('.confirm-delete');

        if (overlay) overlay.remove();
        if (dialog) dialog.remove();
    }

    function setupChartEventListeners() {
        const altitudeContainer = document.getElementById('altitudeChartContainer');
        const speedContainer = document.getElementById('speedChartContainer');

        [altitudeContainer, speedContainer].forEach(container => {
            if (container) {
                container.addEventListener('mouseleave', () => {
                    console.log('üñ±Ô∏è Mouse left chart container');
                    hideHoverMarker();
                    hideInfoPopup();
                });

                container.addEventListener('mouseenter', () => {
                    console.log('üñ±Ô∏è Mouse entered chart container');
                });
            }
        });

        const chartsContainer = document.querySelector('.charts-container');
        if (chartsContainer) {
            chartsContainer.addEventListener('mouseleave', () => {
                console.log('üñ±Ô∏è Mouse left charts area');
                hideHoverMarker();
                hideInfoPopup();
            });
        }

        addDebugMessage('Chart event listeners configured', 'system');
    }

    function toggleDebugPopup() {
        const popup = document.getElementById('debugPopup');
        const overlay = document.getElementById('debugOverlay');
        const button = document.getElementById('debugToggle');

        if (popup.style.display === 'flex') {
            popup.style.display = 'none';
            overlay.style.display = 'none';
            button.textContent = 'Show Debug Data';
        } else {
            popup.style.display = 'flex';
            overlay.style.display = 'block';
            button.textContent = 'Hide Debug Data';

            const content = document.getElementById('debugContent');
            content.scrollTop = content.scrollHeight;
        }
    }

    function addDebugMessage(message, type) {
        if (debugPaused) return;

        const now = new Date();
        const timestamp = now.toISOString().split('T')[1].split('.')[0];

        debugMessages.push({
            timestamp: timestamp,
            message: message,
            type: type
        });

        if (debugMessages.length > maxDebugMessages) {
            debugMessages.shift();
        }

        updateDebugContent();
    }

    function updateDebugContent() {
        const content = document.getElementById('debugContent');
        if (!content) return;

        const filterText = document.getElementById('debugFilter').value.toLowerCase();
        const wasAtBottom = content.scrollHeight - content.clientHeight <= content.scrollTop + 5;

        let html = '';
        debugMessages.forEach(entry => {
            if (filterText && !entry.message.toLowerCase().includes(filterText) &&
                !entry.type.toLowerCase().includes(filterText)) {
                return;
            }

            let messageClass = 'message';
            if (entry.type === 'update') messageClass += ' update-message';
            if (entry.type === 'history_batch') messageClass += ' batch-message';
            if (entry.type === 'error') messageClass += ' error-message';

            html += `<div class="${messageClass}">
                <span class="message-timestamp">[${entry.timestamp}]</span>
                <span class="message-type">[${entry.type}]</span>
                <pre>${entry.message}</pre>
            </div>`;
        });

        content.innerHTML = html;

        if (wasAtBottom) {
            content.scrollTop = content.scrollHeight;
        }
    }

    function filterDebugMessages() {
        updateDebugContent();
    }

    function clearDebugLog() {
        debugMessages = [];
        updateDebugContent();
        addDebugMessage('Debug log cleared', 'system');
    }

    function pauseDebugLog() {
        debugPaused = !debugPaused;
        const pauseButton = document.getElementById('pauseButton');
        pauseButton.textContent = debugPaused ? 'Resume' : 'Pause';

        if (!debugPaused) {
            addDebugMessage('Debug logging resumed', 'system');
        }
    }

    function exportDebugLog() {
        const content = debugMessages.map(entry =>
            `[${entry.timestamp}] [${entry.type}] ${entry.message}`
        ).join('\n');

        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `debug-log-${new Date().toISOString().split('.')[0].replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        addDebugMessage('Debug log exported', 'system');
    }

    function logWeatherData(data) {
        if (data.temperature !== undefined && data.temperature > 0) {
            const weatherDesc = getWeatherDescription(data.weatherCode || 0);
            const windDir = getWindDirectionText(data.windDirection || 0);

            addDebugMessage(
                `Weather Update: ${data.temperature}¬∞C, ${data.relativeHumidity}% humidity, ` +
                `${data.windSpeed}km/h ${windDir} wind, ${weatherDesc}`,
                'weather'
            );
        }
    }

    function validateWeatherData(point) {
        const weatherFields = ['temperature', 'windSpeed', 'windDirection', 'relativeHumidity', 'weatherCode'];
        const hasWeatherData = weatherFields.some(field =>
            point[field] !== undefined && point[field] !== null && point[field] !== 0
        );

        if (hasWeatherData) {
            addDebugMessage(`Valid weather data found in point: ${JSON.stringify({
                temp: point.temperature,
                wind: point.windSpeed,
                humidity: point.relativeHumidity,
                code: point.weatherCode
            })}`, 'weather');
        } else {
            addDebugMessage('No weather data found in this point', 'weather');
        }

        return hasWeatherData;
    }

    function updateWeatherStats(point) {
        if (point.temperature !== undefined && point.temperature > 0) {
            weatherStats.totalUpdates++;
            weatherStats.lastTemperature = point.temperature;
            weatherStats.lastUpdate = new Date();

            if (weatherStats.temperatureRange.min === null || point.temperature < weatherStats.temperatureRange.min) {
                weatherStats.temperatureRange.min = point.temperature;
            }
            if (weatherStats.temperatureRange.max === null || point.temperature > weatherStats.temperatureRange.max) {
                weatherStats.temperatureRange.max = point.temperature;
            }

            if (weatherStats.totalUpdates % 10 === 0) {
                addDebugMessage(
                    `Weather Stats: ${weatherStats.totalUpdates} updates, ` +
                    `Temp range: ${weatherStats.temperatureRange.min}¬∞C - ${weatherStats.temperatureRange.max}¬∞C, ` +
                    `Last: ${weatherStats.lastTemperature}¬∞C`,
                    'weather-stats'
                );
            }
        }
    }

    function shouldDisplaySession(sessionId) {
        return !sessionId.includes('_reset_') && !sessionId.includes('_archived_');
    }

    document.addEventListener('DOMContentLoaded', () => {
        try {
            console.log("DOM content loaded, initializing application...");

            initMap();

            addDebugMessage('Running Tracker application initialized with session management and weather data support (GPX upload controls removed)', 'system');

            setupChartEventListeners();

            setTimeout(() => {
                if (altitudeChart && speedChart) {
                    addDebugMessage('Charts initialized successfully with hover support', 'system');
                } else {
                    addDebugMessage('Chart initialization may have failed', 'error');
                }
            }, 1000);

        } catch (error) {
            console.error("Error during application initialization:", error);
            alert("There was an error initializing the application. Please check the console for details.");
        }
    });
</script>
</body>
</html>