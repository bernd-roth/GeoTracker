<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Tracker - Speed & Elevation Display</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        body,
        html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        }
        #map {
        height: 67vh;
        width: 100%;
        }
        #gpxUpload {
        position: absolute;
        top: 12px;
        left: 50px;
        z-index: 1000;
        background-color: white;
        padding: 5px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
        gap: 0px;
        align-items: flex-start;
        }
        .gpx-controls {
        display: flex;
        gap: 5px;
        align-items: center;
        }
        #gpxUpload input[type="file"] {
        font-size: 12px;
        max-width: 200px;
        }
        #gpxUpload button {
        padding: 4px 8px;
        background-color: white;
        border: 2px solid rgba(0,0,0,0.2);
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
        color: #666;
        }
        #gpxUpload button:hover {
        background-color: #f4f4f4;
        }
        /* Modified speedDisplay to have a fixed height and scrolling */
        #speedDisplay {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 1000;
        background-color: white;
        padding: 10px 0;
        border-radius: 5px;
        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
        font-family: Arial, sans-serif;
        width: 280px;
        max-height: 600px; /* Set a max height for 2 sessions */
        overflow-y: auto; /* Enable scrolling */
        display: block;
        }
        .stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        padding: 10px;
        }
        .stat-box {
        background-color: #f5f5f5;
        padding: 10px;
        border-radius: 4px;
        text-align: center;
        }
        .speed-value {
        font-size: 24px;
        font-weight: bold;
        color: #2196F3;
        }
        .elevation-value {
        font-size: 24px;
        font-weight: bold;
        color: #4CAF50;
        }
        .speed-unit, .elevation-unit {
        font-size: 14px;
        color: #666;
        }
        .speed-label, .elevation-label {
        font-size: 12px;
        color: #999;
        margin-bottom: 5px;
        }
        .charts-container {
        height: 33vh;
        width: 100%;
        display: flex;
        padding: 0;
        }
        #altitudeChartContainer,
        #speedChartContainer {
        height: 100%;
        width: 50%;
        padding: 0;
        }
        #altitudeChart,
        #speedChart {
        height: 100%;
        width: 100%;
        }
        .session-info {
        position: fixed;
        bottom: 10px;
        left: 10px;
        background-color: white;
        padding: 5px 10px;
        border-radius: 3px;
        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
        font-family: Arial, sans-serif;
        font-size: 12px;
        color: #333;
        z-index: 1000;
        transform: none;
        display: inline-block;
        }
        /* Session container styles */
        .session-container {
        margin-bottom: 10px;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
        }
        .session-container:last-child {
        border-bottom: none;
        margin-bottom: 0;
        }
        .session-label {
        font-size: 12px;
        font-weight: bold;
        padding: 0 10px;
        margin-bottom: 5px;
        color: #333;
        }
        /* Scrollbar styling */
        #speedDisplay::-webkit-scrollbar {
        width: 6px;
        }
        #speedDisplay::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
        }
        #speedDisplay::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 3px;
        }
        #speedDisplay::-webkit-scrollbar-thumb:hover {
        background: #555;
        }
        /* Debug Popup Styles */
        #debugToggle {
        position: absolute;
        top: 38px;
        left: 0px;
        z-index: 1000;
        background-color: white;
        padding: 5px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        }
        #debugToggle:hover {
        background-color: #0b7dda;
        }
        #debugPopup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%;
        max-width: 900px;
        height: 80%;
        max-height: 600px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        z-index: 2000;
        overflow: hidden;
        flex-direction: column;
        }
        #debugPopupHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        background-color: #f3f3f3;
        border-bottom: 1px solid #ddd;
        }
        #debugPopupTitle {
        font-weight: bold;
        margin: 0;
        }
        #debugPopupClose {
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #666;
        }
        #debugContent {
        flex: 1;
        padding: 15px;
        overflow: auto;
        font-family: monospace;
        font-size: 13px;
        line-height: 1.5;
        }
        .debug-controls {
        display: flex;
        padding: 10px 15px;
        background-color: #f3f3f3;
        border-top: 1px solid #ddd;
        gap: 10px;
        }
        .debug-controls button {
        padding: 6px 12px;
        background-color: #2196F3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
        }
        .debug-controls button:hover {
        background-color: #0b7dda;
        }
        #debugFilter {
        flex: 1;
        padding: 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        }
        #debugContent .message {
        margin-bottom: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid #eee;
        word-wrap: break-word;
        }
        #debugContent .message-timestamp {
        color: #999;
        font-size: 11px;
        margin-right: 8px;
        }
        #debugContent .update-message {
        color: #4CAF50;
        }
        #debugContent .batch-message {
        color: #2196F3;
        }
        .message-highlight {
        background-color: #FFFF88;
        }
        #debugOverlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1999;
        }
    </style>
</head>
<body>
<div id="gpxUpload">
    <div class="gpx-controls">
        <input type="file" id="gpxFile" accept=".gpx" />
        <button onclick="loadGPX()">Load GPX</button>
        <button id="resetMapBtn" onclick="resetMap()">Reset Map</button>
        <button id="toggleStatsBtn" onclick="toggleStatBoxes()">Hide Stats</button>
    </div>
    <div>
        <button id="debugToggle" onclick="toggleDebugPopup()">Show Debug Data</button>
    </div>
</div>
<div id="speedDisplay">
    <div class="stats-grid">
        <div class="stat-box">
            <div class="speed-label">Current Speed</div>
            <div class="speed-value" id="currentSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Maximum Speed</div>
            <div class="speed-value" id="maxSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Average Speed</div>
            <div class="speed-value" id="avgSpeed">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="speed-label">Moving Average</div>
            <div class="speed-value" id="movingAvg">0.0</div>
            <div class="speed-unit">km/h</div>
        </div>
        <div class="stat-box">
            <div class="elevation-label">Elevation Gain</div>
            <div class="elevation-value" id="elevationGain">0.0</div>
            <div class="elevation-unit">m</div>
        </div>
    </div>
</div>
<div id="map"></div>
<div class="charts-container">
    <div id="altitudeChartContainer">
        <canvas id="altitudeChart"></canvas>
    </div>
    <div id="speedChartContainer">
        <canvas id="speedChart"></canvas>
    </div>
</div>
<div id="sessionInfo" class="session-info"></div>

<!-- Debug Popup -->
<div id="debugOverlay" onclick="toggleDebugPopup()"></div>
<div id="debugPopup">
    <div id="debugPopupHeader">
        <h3 id="debugPopupTitle">Data Trace Debug</h3>
        <button id="debugPopupClose" onclick="toggleDebugPopup()">×</button>
    </div>
    <div id="debugContent"></div>
    <div class="debug-controls">
        <input type="text" id="debugFilter" placeholder="Filter messages..." oninput="filterDebugMessages()">
        <button onclick="clearDebugLog()">Clear Log</button>
        <button onclick="exportDebugLog()">Export Log</button>
        <button onclick="pauseDebugLog()" id="pauseButton">Pause</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Global variables
    let map;
    let websocket;
    let polylines = {};
    let startMarkers = {};
    let endMarkers = {};
    let gpxPolyline;
    let altitudeChart;
    let speedChart;
    let speedHistory = {};
    let elevationHistory = {}; // Added to track elevation gain
    let userColors = {};
    let trackPoints = {};
    let isProcessingBatch = false;
    let statsVisible = true; // Track the visibility state of stat boxes
    let sessionPersonNames = {};

    // Debug variables
    let debugMessages = [];
    let debugPaused = false;
    let maxDebugMessages = 1000; // Limit to prevent browser slowdown

    function getRandomInRange(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function initMap() {
        try {
            console.log("Initializing map...");
            const initialLocation = [48.1818798, 16.3607528]; // Use Vienna as default location
            map = L.map('map', {
                worldCopyJump: false,
                maxBounds: [[-90, -180], [90, 180]],
                minZoom: 1
            }).setView(initialLocation, 6);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                noWrap: true
            }).addTo(map);

            console.log("Map initialized successfully");

            initCharts();
            connectToWebSocket();
        } catch (error) {
            console.error("Error initializing map:", error);
            // Try to provide visual feedback that map initialization failed
            const mapElement = document.getElementById('map');
            if (mapElement) {
                mapElement.innerHTML = '<div style="text-align: center; padding: 20px; color: red;">Error loading map. Please check console for details.</div>';
            }
        }
    }

    function initCharts() {
        const chartOptions = {
            maintainAspectRatio: false,
            animation: false, // Disable animations for better performance
            elements: {
                line: {
                    tension: 0 // Disable bezier curves for better performance
                },
                point: {
                    radius: 0 // Hide points for better performance
                }
            },
            scales: {
                x: {
                    type: 'linear',
                    title: {
                        display: true,
                        text: 'Distance (km)'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Altitude (m)'
                    },
                    min: 0
                }
            },
            plugins: {
                legend: {
                    onClick: handleLegendClick
                }
           }
        };

        altitudeChart = new Chart(
            document.getElementById('altitudeChart').getContext('2d'),
            {
                type: 'line',
                data: { datasets: [] },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            text: 'Altitude (m)'
                        }
                    }
                }
            }
        );

        speedChart = new Chart(
            document.getElementById('speedChart').getContext('2d'),
            {
                type: 'line',
                data: { datasets: [] },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Speed (km/h)'
                            }
                        }
                    }
                }
            }
        );
    }

    // Function to toggle stat boxes visibility
    function toggleStatBoxes() {
        const speedDisplay = document.getElementById('speedDisplay');
        const toggleBtn = document.getElementById('toggleStatsBtn');

        if (statsVisible) {
            // Hide the entire speed display container
            speedDisplay.style.display = 'none';
            toggleBtn.textContent = 'Show Stats';
            statsVisible = false;
        } else {
            // Show the speed display container
            speedDisplay.style.display = 'block';
            toggleBtn.textContent = 'Hide Stats';
            statsVisible = true;
        }

        addDebugMessage(`Stats visibility toggled: ${statsVisible ? 'shown' : 'hidden'}`, 'system');
    }

    function handleLegendClick(e, legendItem, legend) {
        const index = legendItem.datasetIndex;
        const sessionId = legend.chart.data.datasets[index].label;
        const isVisible = legend.chart.isDatasetVisible(index);

        // Toggle visibility in both charts
        [altitudeChart, speedChart].forEach(chart => {
            const datasetIndex = chart.data.datasets.findIndex(ds => ds.label === sessionId);
            if (datasetIndex !== -1) {
                chart.setDatasetVisibility(datasetIndex, !isVisible);
                chart.update();
            }
        });

        // Toggle map elements visibility
        toggleMapElementsVisibility(sessionId, !isVisible);
    }

    function toggleMapElementsVisibility(sessionId, visible) {
        // Extract the actual sessionId from the displayId if necessary
        const actualSessionId = sessionId.includes('_') ? sessionId.split('_').pop() : sessionId;

        // Toggle polyline
        if (polylines[actualSessionId]) {
            if (visible) {
                if (!map.hasLayer(polylines[actualSessionId])) {
                    map.addLayer(polylines[actualSessionId]);
                }
            } else {
                if (map.hasLayer(polylines[actualSessionId])) {
                    map.removeLayer(polylines[actualSessionId]);
                }
            }
        }

        [startMarkers, endMarkers].forEach(markers => {
            if (markers[actualSessionId]) {
                if (visible) {
                    if (!map.hasLayer(markers[actualSessionId])) {
                        map.addLayer(markers[actualSessionId]);
                    }
                } else {
                    if (map.hasLayer(markers[actualSessionId])) {
                        map.removeLayer(markers[actualSessionId]);
                    }
                }
            }
        });

        // Use the container ID
        const speedContainer = document.getElementById(`speed-container-${actualSessionId}`);
        if (speedContainer) {
            speedContainer.style.display = visible ? 'block' : 'none';
        }
    }

    function connectToWebSocket() {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/geotracker`;

        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
            console.log('Connected to WebSocket server');
            addDebugMessage('WebSocket connection established', 'connection');
        };

        websocket.onmessage = (event) => {
            const message = JSON.parse(event.data);

            // Add to debug log first
            addDebugMessage(JSON.stringify(message, null, 2), message.type);

            switch (message.type) {
                case 'history_batch':
                    handleHistoryBatch(message.points);
                    break;
                case 'history_complete':
                    finalizeBatchProcessing();
                    break;
                case 'update':
                    handlePoint(message.point);
                    break;
            }
        };

        websocket.onclose = () => {
            console.log('WebSocket connection closed');
            addDebugMessage('WebSocket connection closed', 'connection');
            setTimeout(connectToWebSocket, 5000); // Reconnect after 5 seconds
        };

        websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            addDebugMessage('WebSocket error: ' + error, 'error');
        };
    }

    function handleHistoryBatch(points) {
        if (!points || points.length === 0) return;

        isProcessingBatch = true;

        points.forEach(point => {
            const sessionId = point.sessionId || "default";
            const personName = point.person || "";

            // Store the person name mapping
            if (personName) {
                sessionPersonNames[sessionId] = personName;
            }

            if (!trackPoints[sessionId]) {
                trackPoints[sessionId] = [];
            }

            // Convert data types and add to trackPoints
            const processedPoint = {
                lat: parseFloat(point.latitude),
                lng: parseFloat(point.longitude),
                distance: parseFloat(point.distance) / 1000, // Convert to kilometers
                altitude: parseFloat(point.altitude || 0),
                speed: parseFloat(point.currentSpeed || 0),
                averageSpeed: parseFloat(point.averageSpeed || 0),
                cumulativeElevationGain: parseFloat(point.cumulativeElevationGain || 0),
                timestamp: new Date(point.timestamp.replace(/(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1')),
                personName: personName
            };

            trackPoints[sessionId].push(processedPoint);
        });
    }

    function finalizeBatchProcessing() {
        if (!isProcessingBatch) return;

        // Sort all sessions by timestamp
        Object.keys(trackPoints).forEach(sessionId => {
            trackPoints[sessionId].sort((a, b) => a.timestamp - b.timestamp);
        });

        // Update visualizations for all sessions
        requestAnimationFrame(() => {
            Object.keys(trackPoints).forEach(sessionId => {
                updateMapTrack(sessionId);
                updateCharts(sessionId);

                // Update speed display with the latest point
                const latestPoint = trackPoints[sessionId][trackPoints[sessionId].length - 1];
                if (latestPoint) {
                    updateSpeedDisplay(sessionId, latestPoint.speed, {
                        averageSpeed: latestPoint.averageSpeed,
                        cumulativeElevationGain: latestPoint.cumulativeElevationGain,
                        personName: latestPoint.personName ||
                            (window.sessionPersonNames && window.sessionPersonNames[sessionId]) || ""
                    });
                }
            });
            isProcessingBatch = false;
        });
    }

    function handlePoint(data) {
        if (!data || isProcessingBatch) return;

        const sessionId = data.sessionId || "default";
        // Extract the person's name from the data
        const personName = data.person || "";

        if (personName) {
            sessionPersonNames[sessionId] = personName;
        }

        // Create a display ID using our helper function
        const displayId = createDisplayId(sessionId, personName);

        const processedPoint = {
            lat: parseFloat(data.latitude),
            lng: parseFloat(data.longitude),
            distance: parseFloat(data.distance) / 1000,
            altitude: parseFloat(data.altitude || 0),
            speed: parseFloat(data.currentSpeed || 0),
            averageSpeed: parseFloat(data.averageSpeed || 0),
            maxSpeed: parseFloat(data.maxSpeed || 0),
            movingAverageSpeed: parseFloat(data.movingAverageSpeed || 0),
            cumulativeElevationGain: parseFloat(data.cumulativeElevationGain || 0),
            timestamp: new Date(data.timestamp.replace(/(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1')),
            // Store the person's name for use in display
            personName: personName
        };

        if (!trackPoints[sessionId]) {
            trackPoints[sessionId] = [];
        }

        trackPoints[sessionId].push(processedPoint);

        // Use requestAnimationFrame for smooth updates
        requestAnimationFrame(() => {
            updateMapTrack(sessionId);
            updateCharts(sessionId);
            updateSpeedDisplay(sessionId, processedPoint.speed, {
                averageSpeed: processedPoint.averageSpeed,
                maxSpeed: processedPoint.maxSpeed,
                movingAverageSpeed: processedPoint.movingAverageSpeed,
                cumulativeElevationGain: processedPoint.cumulativeElevationGain,
                // Pass the person name to the display function
                personName: processedPoint.personName
            });
        });
    }

    function updateMapTrack(sessionId) {
        const points = trackPoints[sessionId];
        if (!points || points.length === 0) return;

        // Remove existing layers
        if (polylines[sessionId]) {
            map.removeLayer(polylines[sessionId]);
        }
        if (startMarkers[sessionId]) {
            map.removeLayer(startMarkers[sessionId]);
        }
        if (endMarkers[sessionId]) {
            map.removeLayer(endMarkers[sessionId]);
        }

        // Create new polyline
        const coordinates = points.map(point => [point.lat, point.lng]);
        const userColor = getColorForUser(sessionId);

        polylines[sessionId] = L.polyline(coordinates, {
            color: userColor,
            weight: 3
        }).addTo(map);

        // Add markers
        startMarkers[sessionId] = L.marker(coordinates[0], {
            title: "Start Position - " + sessionId
        }).bindPopup('Start - ' + sessionId).addTo(map);

        endMarkers[sessionId] = L.marker(coordinates[coordinates.length - 1], {
            title: "Current Position - " + sessionId
        }).bindPopup('Current - ' + sessionId).addTo(map);
    }

    function updateCharts(sessionId) {
        const points = trackPoints[sessionId];
        if (!points || points.length === 0) return;

        // Get the person name from our saved mapping
        const personName = sessionPersonNames[sessionId] || "";

        // Use helper function to create display ID
        const displayId = createDisplayId(sessionId, personName);

        const chartData = points.map(point => ({
            x: point.distance,
            y: point.altitude
        }));

        const speedData = points.map(point => ({
            x: point.distance,
            y: point.speed
        }));

        // Update altitude chart
        let altDatasetIndex = altitudeChart.data.datasets.findIndex(
            dataset => dataset.label === sessionId || dataset.label === displayId
        );

        if (altDatasetIndex === -1) {
            altDatasetIndex = altitudeChart.data.datasets.length;
            altitudeChart.data.datasets.push({
                label: displayId,
                borderColor: getColorForUser(sessionId),
                fill: false,
                data: []
            });
        } else if (personName && altitudeChart.data.datasets[altDatasetIndex].label !== displayId) {
            // Update the label if we now have a person name
            altitudeChart.data.datasets[altDatasetIndex].label = displayId;
        }

        altitudeChart.data.datasets[altDatasetIndex].data = chartData;

        // Update speed chart
        let speedDatasetIndex = speedChart.data.datasets.findIndex(
            dataset => dataset.label === sessionId || dataset.label === displayId
        );

        if (speedDatasetIndex === -1) {
            speedDatasetIndex = speedChart.data.datasets.length;
            speedChart.data.datasets.push({
                label: displayId,
                borderColor: getColorForUser(sessionId),
                fill: false,
                data: []
            });
        } else if (personName && speedChart.data.datasets[speedDatasetIndex].label !== displayId) {
            // Update the label if we now have a person name
            speedChart.data.datasets[speedDatasetIndex].label = displayId;
        }

        speedChart.data.datasets[speedDatasetIndex].data = speedData;

        // Batch update both charts
        requestAnimationFrame(() => {
            altitudeChart.update('none');
            speedChart.update('none');
        });
    }

    function getSpeedColor(speed) {
        if (speed < 5) return '#2196F3';
        if (speed < 10) return '#4CAF50';
        return '#F44336';
    }

    function getElevationColor(elevation) {
        if (elevation < 10) return '#2196F3';  // Low elevation gain
        if (elevation < 50) return '#4CAF50';  // Medium elevation gain
        return '#F44336';                      // High elevation gain
    }

    function updateSpeedDisplay(sessionId, speed, data) {
        // Get the person name from the data or from our saved mapping
        const personName = data.personName || sessionPersonNames[sessionId] || "";

        // Use helper function to create display ID
        const displayId = createDisplayId(sessionId, personName);

        // Initialize or update the speed history
        if (!speedHistory[sessionId]) {
            speedHistory[sessionId] = {
                speeds: [],
                maxSpeed: 0,
                avgSpeed: 0,
                movingAvg: 0,
                elevationGain: 0,
                lastUpdate: new Date(),
                personName: personName
            };
        } else if (personName && !speedHistory[sessionId].personName) {
            // Update the person name if it wasn't set before
            speedHistory[sessionId].personName = personName;
        }

        const history = speedHistory[sessionId];
        history.speeds.push(speed);
        history.lastUpdate = new Date();

        // If stats are hidden, just store the data without updating the DOM
        if (!statsVisible && document.getElementById('speedDisplay').style.display === 'none') {
            if (data.maxSpeed !== undefined) {
                history.maxSpeed = Math.max(history.maxSpeed, data.maxSpeed);
            }

            if (data.cumulativeElevationGain !== undefined) {
                history.elevationGain = data.cumulativeElevationGain;
            }

            // Clean up old sessions
            cleanupOldSessions();
            return;
        }

        // Get the speed display element
        const speedDisplay = document.getElementById('speedDisplay');

        // Check for default display and remove it when first session arrives
        // This happens before we check if the container exists
        const defaultDisplay = speedDisplay.querySelector('.stats-grid:not([id^="speed-grid-"])');
        if (defaultDisplay) {
            // Remove the default display immediately when we get any new session
            defaultDisplay.remove();
            console.log("Removed default display when handling session: " + sessionId);
        }

        // Check if a container for this session already exists
        let speedContainer = document.getElementById(`speed-container-${sessionId}`);

        if (!speedContainer) {
            // Create a new container for this session
            speedContainer = document.createElement('div');
            speedContainer.id = `speed-container-${sessionId}`;
            speedContainer.className = 'session-container';

            // Create the grid for this session
            const statsGrid = document.createElement('div');
            statsGrid.id = `speed-grid-${sessionId}`;
            statsGrid.className = 'stats-grid';

            // Add the session label
            const sessionLabel = document.createElement('div');
            sessionLabel.className = 'session-label';
            sessionLabel.textContent = displayId;

            // Add these elements to the container
            speedContainer.appendChild(sessionLabel);
            speedContainer.appendChild(statsGrid);

            // Add the container to the speed display
            speedDisplay.appendChild(speedContainer);

            // Create all the stat boxes
            statsGrid.innerHTML = `
                <div class="stat-box">
                    <div class="speed-label">Current Speed</div>
                    <div class="speed-value" id="currentSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Maximum Speed</div>
                    <div class="speed-value" id="maxSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Average Speed</div>
                    <div class="speed-value" id="avgSpeed-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="speed-label">Moving Average</div>
                    <div class="speed-value" id="movingAvg-${sessionId}">0.0</div>
                    <div class="speed-unit">km/h</div>
                </div>
                <div class="stat-box">
                    <div class="elevation-label">Elevation Gain</div>
                    <div class="elevation-value" id="elevationGain-${sessionId}">0.0</div>
                    <div class="elevation-unit">m</div>
                </div>
            `;

            // Auto-scroll to show the new session
            speedDisplay.scrollTop = speedDisplay.scrollHeight;
        } else {
            // Update the session label if the person name has changed
            const sessionLabel = speedContainer.querySelector('.session-label');
            if (sessionLabel && personName) {
                sessionLabel.textContent = displayId;
            }
        }

        // Rest of the function remains the same...
        // Update current speed
        const currentSpeedElement = document.getElementById(`currentSpeed-${sessionId}`);
        if (currentSpeedElement) {
            currentSpeedElement.textContent = speed.toFixed(1);
            currentSpeedElement.style.color = getSpeedColor(speed);
        }

        // Update max speed from the data
        const maxSpeedElement = document.getElementById(`maxSpeed-${sessionId}`);
        if (maxSpeedElement && data.maxSpeed !== undefined) {
            history.maxSpeed = Math.max(history.maxSpeed, data.maxSpeed);
            maxSpeedElement.textContent = history.maxSpeed.toFixed(1);
            maxSpeedElement.style.color = getSpeedColor(history.maxSpeed);
        }

        // Update average speed
        const avgSpeedElement = document.getElementById(`avgSpeed-${sessionId}`);
        if (avgSpeedElement && data.averageSpeed !== undefined) {
            avgSpeedElement.textContent = data.averageSpeed.toFixed(1);
            avgSpeedElement.style.color = getSpeedColor(data.averageSpeed);
        }

        // Update moving average
        const movingAvgElement = document.getElementById(`movingAvg-${sessionId}`);
        if (movingAvgElement && data.movingAverageSpeed !== undefined) {
            movingAvgElement.textContent = data.movingAverageSpeed.toFixed(1);
            movingAvgElement.style.color = getSpeedColor(data.movingAverageSpeed);
        }

        // Update elevation gain
        const elevationGainElement = document.getElementById(`elevationGain-${sessionId}`);
        if (elevationGainElement && data.cumulativeElevationGain !== undefined) {
            history.elevationGain = data.cumulativeElevationGain;
            elevationGainElement.textContent = history.elevationGain.toFixed(1);
            elevationGainElement.style.color = getElevationColor(history.elevationGain);
        }

        // Clean up old sessions
        cleanupOldSessions();
    }

    function cleanupOldSessions() {
        const now = new Date();
        for (const sessionId in speedHistory) {
            const timeDiff = now - speedHistory[sessionId].lastUpdate;
            if (timeDiff > 300000) { // 5 minutes timeout
                // Remove the container instead of just the element
                const container = document.getElementById(`speed-container-${sessionId}`);
                if (container) {
                    container.remove();
                }
                delete speedHistory[sessionId];
            }
        }
    }

    function getSpeedColor(speed) {
        if (speed < 5) return '#2196F3';
        if (speed < 10) return '#4CAF50';
        return '#F44336';
    }

    function getColorForUser(sessionId) {
        if (!userColors[sessionId]) {
            // Generate random RGB values within specific ranges to ensure visibility
            // We'll avoid very light colors (high values) and very dark colors (low values)
            const ranges = [
                // R, G, B ranges for different color characteristics
                [150, 255, 0, 100, 0, 100],    // Reddish
                [0, 100, 150, 255, 0, 100],    // Greenish
                [0, 100, 0, 100, 150, 255],    // Bluish
                [150, 255, 150, 255, 0, 100],  // Yellowish
                [150, 255, 0, 100, 150, 255],  // Purplish
                [0, 100, 150, 255, 150, 255]   // Cyanish
            ];

            // Use the sessionId to consistently select a range
            const hash = sessionId.split('').reduce((acc, char) => {
                return char.charCodeAt(0) + ((acc << 5) - acc);
            }, 0);

            const selectedRange = ranges[Math.abs(hash) % ranges.length];

            // Generate random RGB values within the selected range
            const r = getRandomInRange(selectedRange[0], selectedRange[1]);
            const g = getRandomInRange(selectedRange[2], selectedRange[3]);
            const b = getRandomInRange(selectedRange[4], selectedRange[5]);

            userColors[sessionId] = `rgb(${r}, ${g}, ${b})`;
        }
        return userColors[sessionId];
    }

    function parseSessionId(sessionId) {
        const [name, timestamp] = sessionId.split('_');
        if (!timestamp) return { name: sessionId, timestamp: null };

        const year = timestamp.substr(0, 4);
        const month = timestamp.substr(4, 2);
        const day = timestamp.substr(6, 2);
        const hour = timestamp.substr(9, 2);
        const minute = timestamp.substr(11, 2);
        const second = timestamp.substr(13, 2);

        return {
            name: name,
            formattedTime: `${day}/${month}/${year} ${hour}:${minute}:${second}`
        };
    }

    function resetMap() {
        // Clear all data structures
        trackPoints = {};
        speedHistory = {};
        userColors = {};

        // Reset displays
        document.getElementById('currentSpeed').textContent = '0.0';
        document.getElementById('maxSpeed').textContent = '0.0';
        document.getElementById('avgSpeed').textContent = '0.0';
        document.getElementById('movingAvg').textContent = '0.0';

        // Clear map layers
        Object.values(polylines).forEach(polyline => map.removeLayer(polyline));
        Object.values(startMarkers).forEach(marker => map.removeLayer(marker));
        Object.values(endMarkers).forEach(marker => map.removeLayer(marker));

        polylines = {};
        startMarkers = {};
        endMarkers = {};

        if (gpxPolyline) {
            map.removeLayer(gpxPolyline);
            gpxPolyline = null;
        }

        // Reset charts
        altitudeChart.data.datasets = [];
        speedChart.data.datasets = [];
        altitudeChart.update();
        speedChart.update();

        // Reset map view
        map.setView([48.1818798, 16.3607528], 10);

        // Add debug message
        addDebugMessage('Map reset', 'system');
    }

    // Debug Popup Functions
    function toggleDebugPopup() {
        const popup = document.getElementById('debugPopup');
        const overlay = document.getElementById('debugOverlay');
        const button = document.getElementById('debugToggle');

        if (popup.style.display === 'flex') {
            popup.style.display = 'none';
            overlay.style.display = 'none';
            button.textContent = 'Show Debug Data';
        } else {
            popup.style.display = 'flex';
            overlay.style.display = 'block';
            button.textContent = 'Hide Debug Data';

            // Scroll to bottom when opening
            const content = document.getElementById('debugContent');
            content.scrollTop = content.scrollHeight;
        }
    }

    function addDebugMessage(message, type) {
        if (debugPaused) return;

        const now = new Date();
        const timestamp = now.toISOString().split('T')[1].split('.')[0];

        debugMessages.push({
            timestamp: timestamp,
            message: message,
            type: type
        });

        // Limit the number of messages to prevent browser slowdown
        if (debugMessages.length > maxDebugMessages) {
            debugMessages.shift();
        }

        updateDebugContent();
    }

    function updateDebugContent() {
        const content = document.getElementById('debugContent');
        if (!content) return;

        const filterText = document.getElementById('debugFilter').value.toLowerCase();
        const wasAtBottom = content.scrollHeight - content.clientHeight <= content.scrollTop + 5;

        let html = '';
        debugMessages.forEach(entry => {
            if (filterText && !entry.message.toLowerCase().includes(filterText) &&
                !entry.type.toLowerCase().includes(filterText)) {
                return;
            }

            let messageClass = 'message';
            if (entry.type === 'update') messageClass += ' update-message';
            if (entry.type === 'history_batch') messageClass += ' batch-message';
            if (entry.type === 'error') messageClass += ' error-message';

            html += `<div class="${messageClass}">
                <span class="message-timestamp">[${entry.timestamp}]</span>
                <span class="message-type">[${entry.type}]</span>
                <pre>${entry.message}</pre>
            </div>`;
        });

        content.innerHTML = html;

        // If previously at bottom, scroll to bottom after update
        if (wasAtBottom) {
            content.scrollTop = content.scrollHeight;
        }
    }

    function filterDebugMessages() {
        updateDebugContent();
    }

    function clearDebugLog() {
        debugMessages = [];
        updateDebugContent();
        addDebugMessage('Debug log cleared', 'system');
    }

    function pauseDebugLog() {
        debugPaused = !debugPaused;
        const pauseButton = document.getElementById('pauseButton');
        pauseButton.textContent = debugPaused ? 'Resume' : 'Pause';

        if (!debugPaused) {
            addDebugMessage('Debug logging resumed', 'system');
        }
    }

    function exportDebugLog() {
        const content = debugMessages.map(entry =>
            `[${entry.timestamp}] [${entry.type}] ${entry.message}`
        ).join('\n');

        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `debug-log-${new Date().toISOString().split('.')[0].replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        addDebugMessage('Debug log exported', 'system');
    }

    // GPX file handling
    async function loadGPX() {
        const fileInput = document.getElementById('gpxFile');
        const file = fileInput.files[0];

        if (!file) {
            alert('Please select a GPX file first.');
            addDebugMessage('GPX file load attempted but no file selected', 'error');
            return;
        }

        addDebugMessage(`Loading GPX file: ${file.name}`, 'gpx');

        try {
            const gpxText = await readFileAsync(file);
            addDebugMessage(`GPX file loaded: ${file.name} (${Math.round(gpxText.length / 1024)} KB)`, 'gpx');

            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxText, "text/xml");

            // Reset previous GPX data
            if (gpxPolyline) {
                map.removeLayer(gpxPolyline);
            }

            const trackPoints = processGPXTrack(gpxDoc);
            if (!trackPoints.coordinates.length) {
                alert('No valid track points found in GPX file.');
                addDebugMessage('No valid track points found in GPX file', 'error');
                return;
            }

            addDebugMessage(`Processed GPX track: ${trackPoints.coordinates.length} points`, 'gpx');
            visualizeGPXData(trackPoints);

        } catch (error) {
            console.error('Error processing GPX file:', error);
            alert('Error processing GPX file. Please check the console for details.');
            addDebugMessage(`Error processing GPX file: ${error.message}`, 'error');
        }
    }

    function readFileAsync(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsText(file);
        });
    }

    function processGPXTrack(gpxDoc) {
        const trackPoints = {
            coordinates: [],
            altitudes: [],
            times: [],
            distances: [0]
        };

        addDebugMessage('Starting GPX track processing', 'gpx');

        const points = gpxDoc.getElementsByTagName('trkpt');
        let lastCoord = null;

        for (let point of points) {
            const lat = parseFloat(point.getAttribute('lat'));
            const lon = parseFloat(point.getAttribute('lon'));
            const ele = point.getElementsByTagName('ele')[0];
            const time = point.getElementsByTagName('time')[0];

            trackPoints.coordinates.push([lat, lon]);

            if (ele) {
                trackPoints.altitudes.push(parseFloat(ele.textContent));
            }

            if (time) {
                trackPoints.times.push(new Date(time.textContent));
            }

            // Calculate cumulative distance
            if (lastCoord) {
                const distance = map.distance(lastCoord, [lat, lon]);
                trackPoints.distances.push(
                    trackPoints.distances[trackPoints.distances.length - 1] + distance
                );
            }
            lastCoord = [lat, lon];
        }

        // Convert distances to kilometers
        trackPoints.distances = trackPoints.distances.map(d => d / 1000);

        // Log summary stats
        const totalDistance = trackPoints.distances[trackPoints.distances.length - 1];
        let minAlt = Infinity, maxAlt = -Infinity;
        if (trackPoints.altitudes.length > 0) {
            minAlt = Math.min(...trackPoints.altitudes);
            maxAlt = Math.max(...trackPoints.altitudes);
        }

        addDebugMessage(`GPX track processed: ${trackPoints.coordinates.length} points,
            Distance: ${totalDistance.toFixed(2)} km,
            Altitude range: ${minAlt.toFixed(1)}m - ${maxAlt.toFixed(1)}m`, 'gpx');

        return trackPoints;
    }

    function visualizeGPXData(trackPoints) {
        addDebugMessage('Visualizing GPX data on map and charts', 'gpx');

        // Draw track on map
        gpxPolyline = L.polyline(trackPoints.coordinates, {
            color: 'red',
            weight: 3
        }).addTo(map);

        // Fit map to track bounds
        map.fitBounds(gpxPolyline.getBounds());

        const bounds = gpxPolyline.getBounds();
        addDebugMessage(`Map bounds adjusted to: SW(${bounds.getSouthWest().lat.toFixed(4)}, ${bounds.getSouthWest().lng.toFixed(4)})
            NE(${bounds.getNorthEast().lat.toFixed(4)}, ${bounds.getNorthEast().lng.toFixed(4)})`, 'gpx');

        // Update altitude chart
        if (trackPoints.altitudes.length > 0) {
            const altDatasetIndex = altitudeChart.data.datasets.findIndex(
                dataset => dataset.label === 'GPX Track'
            );

            if (altDatasetIndex !== -1) {
                altitudeChart.data.datasets.splice(altDatasetIndex, 1);
            }

            altitudeChart.data.datasets.push({
                label: 'GPX Track',
                borderColor: 'red',
                fill: false,
                data: trackPoints.distances.map((d, i) => ({
                    x: d,
                    y: trackPoints.altitudes[i]
                }))
            });

            // Update speed chart if times are available
            if (trackPoints.times.length > 0) {
                updateSpeedChartFromGPX(trackPoints);
            }

            requestAnimationFrame(() => {
                altitudeChart.update('none');
                speedChart.update('none');
            });
        }
    }

    function updateSpeedChartFromGPX(trackPoints) {
        const speeds = [];

        for (let i = 1; i < trackPoints.times.length; i++) {
            const timeDiff = (trackPoints.times[i] - trackPoints.times[i - 1]) / 1000; // seconds
            const dist = trackPoints.distances[i] - trackPoints.distances[i - 1]; // kilometers

            if (timeDiff > 0) {
                // Convert to km/h
                const speed = (dist / timeDiff) * 3600;
                speeds.push({
                    x: trackPoints.distances[i],
                    y: speed
                });
            }
        }

        const speedDatasetIndex = speedChart.data.datasets.findIndex(
            dataset => dataset.label === 'GPX Track'
        );

        if (speedDatasetIndex !== -1) {
            speedChart.data.datasets.splice(speedDatasetIndex, 1);
        }

        speedChart.data.datasets.push({
            label: 'GPX Track',
            borderColor: 'red',
            fill: false,
            data: speeds
        });

        addDebugMessage(`Speed chart updated with ${speeds.length} calculated speed points from GPX`, 'gpx');
    }

    function createDisplayId(sessionId, personName) {
        if (!personName) return sessionId;

        // Check if the sessionId already starts with the person name to avoid duplication
        if (sessionId.startsWith(personName + '_')) {
            return sessionId;  // Session ID already includes the name properly
        } else {
            return `${personName}_${sessionId}`;  // Combine name with session ID
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        try {
            console.log("DOM content loaded, initializing application...");

            // Initialize the map only once
            initMap();

            // Add custom styling for the stats container
            const style = document.createElement('style');
            style.textContent = `
                #speedDisplay {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    z-index: 1000;
                    background-color: white;
                    padding: 10px 0;
                    border-radius: 5px;
                    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);
                    font-family: Arial, sans-serif;
                    width: 280px;
                    max-height: 300px; /* Limit height to fit approximately 2 session boxes */
                    overflow-y: auto; /* Enable scrolling when content exceeds max-height */
                    display: block;
                }

                .session-container {
                    margin-bottom: 10px;
                    border-bottom: 1px solid #eee;
                    padding-bottom: 10px;
                }

                .session-container:last-child {
                    border-bottom: none;
                    margin-bottom: 0;
                }

                .session-label {
                    font-size: 12px;
                    font-weight: bold;
                    padding: 0 10px;
                    margin-bottom: 5px;
                    color: #333;
                }

                /* Custom scrollbar styling */
                #speedDisplay::-webkit-scrollbar {
                    width: 6px;
                }

                #speedDisplay::-webkit-scrollbar-track {
                    background: #f1f1f1;
                    border-radius: 3px;
                }

                #speedDisplay::-webkit-scrollbar-thumb {
                    background: #888;
                    border-radius: 3px;
                }

                #speedDisplay::-webkit-scrollbar-thumb:hover {
                    background: #555;
                }
            `;
            document.head.appendChild(style);

            addDebugMessage('Running Tracker application initialized with scrollable stats', 'system');
        } catch (error) {
            console.error("Error during application initialization:", error);
            alert("There was an error initializing the application. Please check the console for details.");
        }
    });
</script>
</body>
</html>